{"version":3,"file":"586.js","mappings":"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","sources":["webpack://trilium/./src/public/app/components/root_command_executor.js","webpack://trilium/./src/public/app/components/entrypoints.js","webpack://trilium/./src/public/app/components/note_context.js","webpack://trilium/./src/public/app/utils/mutex.js","webpack://trilium/./src/public/app/components/tab_manager.js","webpack://trilium/./src/public/app/components/mobile_screen_switcher.js","webpack://trilium/./src/public/app/components/main_tree_executors.js","webpack://trilium/./src/public/app/components/shortcut_component.js","webpack://trilium/./src/public/app/components/app_context.js","webpack://trilium/./src/public/app/components/component.js","webpack://trilium/./src/public/app/components/zoom.js","webpack://trilium/./src/public/app/entities/fattachment.js","webpack://trilium/./src/public/app/entities/fattribute.js","webpack://trilium/./src/public/app/entities/fbranch.js","webpack://trilium/./src/public/app/services/css_class_manager.js","webpack://trilium/./src/public/app/entities/fnote.js","webpack://trilium/./src/public/app/menus/context_menu.js","webpack://trilium/./src/public/app/menus/image_context_menu.js","webpack://trilium/./src/public/app/menus/link_context_menu.js","webpack://trilium/./src/public/app/services/attribute_renderer.js","webpack://trilium/./src/public/app/services/bundle.js","webpack://trilium/./src/public/app/services/content_renderer.js","webpack://trilium/./src/public/app/services/date_notes.js","webpack://trilium/./src/public/app/services/dialog.js","webpack://trilium/./src/public/app/entities/fblob.js","webpack://trilium/./src/public/app/services/froca.js","webpack://trilium/./src/public/app/services/hoisted_note.js","webpack://trilium/./src/public/app/services/image.js","webpack://trilium/./src/public/app/services/keyboard_actions.js","webpack://trilium/./src/public/app/services/library_loader.js","webpack://trilium/./src/public/app/services/link.js","webpack://trilium/./src/public/app/services/note_attribute_cache.js","webpack://trilium/./src/public/app/services/note_create.js","webpack://trilium/./src/public/app/services/note_tooltip.js","webpack://trilium/./src/public/app/services/open.js","webpack://trilium/./src/public/app/services/options.js","webpack://trilium/./src/public/app/services/promoted_attribute_definition_parser.js","webpack://trilium/./src/public/app/services/protected_session.js","webpack://trilium/./src/public/app/services/protected_session_holder.js","webpack://trilium/./src/public/app/services/render.js","webpack://trilium/./src/public/app/services/frontend_script_api.js","webpack://trilium/./src/public/app/services/script_context.js","webpack://trilium/./src/public/app/services/search.js","webpack://trilium/./src/public/app/services/validation_error.js","webpack://trilium/./src/public/app/services/server.js","webpack://trilium/./src/public/app/services/spaced_update.js","webpack://trilium/./src/public/app/services/toast.js","webpack://trilium/./src/public/app/services/tree.js","webpack://trilium/./src/public/app/services/load_results.js","webpack://trilium/./src/public/app/services/froca_updater.js","webpack://trilium/./src/public/app/services/ws.js","webpack://trilium/./src/public/app/widgets/basic_widget.js","webpack://trilium/./src/public/app/widgets/note_context_aware_widget.js","webpack://trilium/./src/public/app/widgets/right_panel_widget.js"],"sourcesContent":["import Component from \"./component.js\";\nimport appContext from \"./app_context.js\";\nimport dateNoteService from \"../services/date_notes.js\";\nimport treeService from \"../services/tree.js\";\nimport openService from \"../services/open.js\";\nimport protectedSessionService from \"../services/protected_session.js\";\nimport options from \"../services/options.js\";\nimport froca from \"../services/froca.js\";\nimport utils from \"../services/utils.js\";\n\nexport default class RootCommandExecutor extends Component {\n    editReadOnlyNoteCommand() {\n        const noteContext = appContext.tabManager.getActiveContext();\n        noteContext.viewScope.readOnlyTemporarilyDisabled = true;\n\n        appContext.triggerEvent(\"readOnlyTemporarilyDisabled\", { noteContext });\n    }\n\n    async showSQLConsoleCommand() {\n        const sqlConsoleNote = await dateNoteService.createSqlConsole();\n\n        const noteContext = await appContext.tabManager.openTabWithNoteWithHoisting(sqlConsoleNote.noteId, { activate: true });\n\n        appContext.triggerEvent('focusOnDetail', {ntxId: noteContext.ntxId});\n    }\n\n    async searchNotesCommand({searchString, ancestorNoteId}) {\n        const searchNote = await dateNoteService.createSearchNote({searchString, ancestorNoteId});\n\n        // force immediate search\n        await froca.loadSearchNote(searchNote.noteId);\n\n        const noteContext = await appContext.tabManager.openTabWithNoteWithHoisting(searchNote.noteId, {\n            activate: true\n        });\n\n        appContext.triggerCommand('focusOnSearchDefinition', {ntxId: noteContext.ntxId});\n    }\n\n    async searchInSubtreeCommand({notePath}) {\n        const noteId = treeService.getNoteIdFromUrl(notePath);\n\n        this.searchNotesCommand({ancestorNoteId: noteId});\n    }\n\n    openNoteExternallyCommand() {\n        const noteId = appContext.tabManager.getActiveContextNoteId();\n        const mime = appContext.tabManager.getActiveContextNoteMime();\n        if (noteId) {\n            openService.openNoteExternally(noteId, mime);\n        }\n    }\n\n    openNoteCustomCommand() {\n        const noteId = appContext.tabManager.getActiveContextNoteId();\n        const mime = appContext.tabManager.getActiveContextNoteMime();\n        if (noteId) {\n            openService.openNoteCustom(noteId, mime);\n        }\n    }\n\n    enterProtectedSessionCommand() {\n        protectedSessionService.enterProtectedSession();\n    }\n\n    leaveProtectedSessionCommand() {\n        protectedSessionService.leaveProtectedSession();\n    }\n\n    hideLeftPaneCommand() {\n        options.save(`leftPaneVisible`, \"false\");\n    }\n\n    showLeftPaneCommand() {\n        options.save(`leftPaneVisible`, \"true\");\n    }\n\n    toggleLeftPaneCommand() {\n        options.toggle('leftPaneVisible');\n    }\n\n    async showBackendLogCommand() {\n        await appContext.tabManager.openTabWithNoteWithHoisting('_backendLog', { activate: true });\n    }\n\n    async showLaunchBarSubtreeCommand() {\n        await this.showAndHoistSubtree('_lbRoot');\n    }\n\n    async showShareSubtreeCommand() {\n        await this.showAndHoistSubtree('_share');\n    }\n\n    async showHiddenSubtreeCommand() {\n        await this.showAndHoistSubtree('_hidden');\n    }\n\n    async showOptionsCommand({section}) {\n        await appContext.tabManager.openContextWithNote(section || '_options', {\n            activate: true,\n            hoistedNoteId: '_options'\n        });\n    }\n\n    async showSQLConsoleHistoryCommand() {\n        await this.showAndHoistSubtree('_sqlConsole');\n    }\n\n    async showSearchHistoryCommand() {\n        await this.showAndHoistSubtree('_search');\n    }\n\n    async showAndHoistSubtree(subtreeNoteId) {\n        await appContext.tabManager.openContextWithNote(subtreeNoteId, {\n            activate: true,\n            hoistedNoteId: subtreeNoteId\n        });\n    }\n\n    async showNoteSourceCommand() {\n        const notePath = appContext.tabManager.getActiveContextNotePath();\n\n        if (notePath) {\n            await appContext.tabManager.openTabWithNoteWithHoisting(notePath, {\n                activate: true,\n                viewScope: {\n                    viewMode: 'source'\n                }\n            });\n        }\n    }\n\n    async showAttachmentsCommand() {\n        const notePath = appContext.tabManager.getActiveContextNotePath();\n\n        if (notePath) {\n            await appContext.tabManager.openTabWithNoteWithHoisting(notePath, {\n                activate: true,\n                viewScope: {\n                    viewMode: 'attachments'\n                }\n            });\n        }\n    }\n\n    async showAttachmentDetailCommand() {\n        const notePath = appContext.tabManager.getActiveContextNotePath();\n\n        if (notePath) {\n            await appContext.tabManager.openTabWithNoteWithHoisting(notePath, {\n                activate: true,\n                viewScope: {\n                    viewMode: 'attachments'\n                }\n            });\n        }\n    }\n\n    toggleTrayCommand() {\n        if (!utils.isElectron()) return;\n        const {BrowserWindow} = utils.dynamicRequire('@electron/remote');\n        const windows = BrowserWindow.getAllWindows();\n        const isVisible = windows.every(w => w.isVisible());\n        const action = isVisible ? \"hide\" : \"show\"\n        for (const window of windows) window[action]();\n    }\n\n    firstTabCommand()   { this.#goToTab(1); }\n    secondTabCommand()  { this.#goToTab(2); }\n    thirdTabCommand()   { this.#goToTab(3); }\n    fourthTabCommand()  { this.#goToTab(4); }\n    fifthTabCommand()   { this.#goToTab(5); }\n    sixthTabCommand()   { this.#goToTab(6); }\n    seventhTabCommand() { this.#goToTab(7); }\n    eigthTabCommand()   { this.#goToTab(8); }\n    ninthTabCommand()   { this.#goToTab(9); }\n    lastTabCommand()    { this.#goToTab(Number.POSITIVE_INFINITY); }\n\n    #goToTab(tabNumber) {\n        const mainNoteContexts = appContext.tabManager.getMainNoteContexts();\n\n        const index = tabNumber === Number.POSITIVE_INFINITY ? mainNoteContexts.length - 1 : tabNumber - 1;\n        const tab = mainNoteContexts[index];\n\n        if (tab) {\n            appContext.tabManager.activateNoteContext(tab.ntxId);\n        }\n    }\n}\n","import utils from \"../services/utils.js\";\nimport dateNoteService from \"../services/date_notes.js\";\nimport protectedSessionHolder from '../services/protected_session_holder.js';\nimport server from \"../services/server.js\";\nimport appContext from \"./app_context.js\";\nimport Component from \"./component.js\";\nimport toastService from \"../services/toast.js\";\nimport ws from \"../services/ws.js\";\nimport bundleService from \"../services/bundle.js\";\nimport froca from \"../services/froca.js\";\nimport linkService from \"../services/link.js\";\n\nexport default class Entrypoints extends Component {\n    constructor() {\n        super();\n\n        if (jQuery.hotkeys) {\n            // hot keys are active also inside inputs and content editables\n            jQuery.hotkeys.options.filterInputAcceptingElements = false;\n            jQuery.hotkeys.options.filterContentEditable = false;\n            jQuery.hotkeys.options.filterTextInputs = false;\n        }\n    }\n\n    openDevToolsCommand() {\n        if (utils.isElectron()) {\n            utils.dynamicRequire('@electron/remote').getCurrentWindow().toggleDevTools();\n        }\n    }\n\n    async createNoteIntoInboxCommand() {\n        const inboxNote = await dateNoteService.getInboxNote();\n\n        const {note} = await server.post(`notes/${inboxNote.noteId}/children?target=into`, {\n            content: '',\n            type: 'text',\n            isProtected: inboxNote.isProtected && protectedSessionHolder.isProtectedSessionAvailable()\n        });\n\n        await ws.waitForMaxKnownEntityChangeId();\n\n        await appContext.tabManager.openTabWithNoteWithHoisting(note.noteId, {activate: true});\n\n        appContext.triggerEvent('focusAndSelectTitle', {isNewNote: true});\n    }\n\n    async toggleNoteHoistingCommand({noteId = appContext.tabManager.getActiveContextNoteId()}) {\n        const noteToHoist = await froca.getNote(noteId);\n        const activeNoteContext = appContext.tabManager.getActiveContext();\n\n        if (noteToHoist.noteId === activeNoteContext.hoistedNoteId) {\n            await activeNoteContext.unhoist();\n        }\n        else if (noteToHoist.type !== 'search') {\n            await activeNoteContext.setHoistedNoteId(noteId);\n        }\n    }\n\n    async hoistNoteCommand({noteId}) {\n        const noteContext = appContext.tabManager.getActiveContext();\n\n        if (noteContext.hoistedNoteId !== noteId) {\n            await noteContext.setHoistedNoteId(noteId);\n        }\n    }\n\n    async unhoistCommand() {\n        const activeNoteContext = appContext.tabManager.getActiveContext();\n\n        if (activeNoteContext) {\n            activeNoteContext.unhoist();\n        }\n    }\n\n    copyWithoutFormattingCommand() {\n        utils.copySelectionToClipboard();\n    }\n\n    toggleFullscreenCommand() {\n        if (utils.isElectron()) {\n            const win = utils.dynamicRequire('@electron/remote').getCurrentWindow();\n\n            if (win.isFullScreenable()) {\n                win.setFullScreen(!win.isFullScreen());\n            }\n        } // outside of electron this is handled by the browser\n    }\n\n    reloadFrontendAppCommand() {\n        utils.reloadFrontendApp();\n    }\n\n    logoutCommand() {\n        const $logoutForm = $('<form action=\"logout\" method=\"POST\">')\n            .append($(`<input type='_hidden' name=\"_csrf\" value=\"${glob.csrfToken}\"/>`));\n\n        $(\"body\").append($logoutForm);\n        $logoutForm.trigger('submit');\n    }\n\n    backInNoteHistoryCommand() {\n        if (utils.isElectron()) {\n            // standard JS version does not work completely correctly in electron\n            const webContents = utils.dynamicRequire('@electron/remote').getCurrentWebContents();\n            const activeIndex = parseInt(webContents.getActiveIndex());\n\n            webContents.goToIndex(activeIndex - 1);\n        }\n        else {\n            window.history.back();\n        }\n    }\n\n    forwardInNoteHistoryCommand() {\n        if (utils.isElectron()) {\n            // standard JS version does not work completely correctly in electron\n            const webContents = utils.dynamicRequire('@electron/remote').getCurrentWebContents();\n            const activeIndex = parseInt(webContents.getActiveIndex());\n\n            webContents.goToIndex(activeIndex + 1);\n        }\n        else {\n            window.history.forward();\n        }\n    }\n\n    async switchToDesktopVersionCommand() {\n        utils.setCookie('trilium-device', 'desktop');\n\n        utils.reloadFrontendApp(\"Switching to desktop version\");\n    }\n\n    async switchToMobileVersionCommand() {\n        utils.setCookie('trilium-device', 'mobile');\n\n        utils.reloadFrontendApp(\"Switching to mobile version\");\n    }\n\n    async openInWindowCommand({notePath, hoistedNoteId, viewScope}) {\n        const extraWindowHash = linkService.calculateHash({notePath, hoistedNoteId, viewScope});\n\n        if (utils.isElectron()) {\n            const {ipcRenderer} = utils.dynamicRequire('electron');\n\n            ipcRenderer.send('create-extra-window', { extraWindowHash });\n        }\n        else {\n            const url = `${window.location.protocol}//${window.location.host}${window.location.pathname}?extraWindow=1${extraWindowHash}`;\n\n            window.open(url, '', 'width=1000,height=800');\n        }\n    }\n\n    async openNewWindowCommand() {\n        this.openInWindowCommand({notePath: '', hoistedNoteId: 'root'});\n    }\n\n    async runActiveNoteCommand() {\n        const {ntxId, note} = appContext.tabManager.getActiveContext();\n\n        // ctrl+enter is also used elsewhere, so make sure we're running only when appropriate\n        if (!note || note.type !== 'code') {\n            return;\n        }\n\n        // TODO: use note.executeScript()\n        if (note.mime.endsWith(\"env=frontend\")) {\n            await bundleService.getAndExecuteBundle(note.noteId);\n        } else if (note.mime.endsWith(\"env=backend\")) {\n            await server.post(`script/run/${note.noteId}`);\n        } else if (note.mime === 'text/x-sqlite;schema=trilium') {\n            const resp = await server.post(`sql/execute/${note.noteId}`);\n\n            if (!resp.success) {\n                toastService.showError(`Error occurred while executing SQL query: ${resp.error}`);\n            }\n\n            await appContext.triggerEvent('sqlQueryResults', {ntxId: ntxId, results: resp.results});\n        }\n\n        toastService.showMessage(\"Note executed\");\n    }\n\n    hideAllPopups() {\n        if (utils.isDesktop()) {\n            $(\".aa-input\").autocomplete(\"close\");\n        }\n    }\n\n    noteSwitchedEvent() {\n        this.hideAllPopups();\n    }\n\n    activeContextChangedEvent() {\n        this.hideAllPopups();\n    }\n\n    async forceSaveRevisionCommand() {\n        const noteId = appContext.tabManager.getActiveContextNoteId();\n\n        await server.post(`notes/${noteId}/revision`);\n\n        toastService.showMessage(\"Note revision has been created.\");\n    }\n}\n","import protectedSessionHolder from \"../services/protected_session_holder.js\";\nimport server from \"../services/server.js\";\nimport utils from \"../services/utils.js\";\nimport appContext from \"./app_context.js\";\nimport treeService from \"../services/tree.js\";\nimport Component from \"./component.js\";\nimport froca from \"../services/froca.js\";\nimport hoistedNoteService from \"../services/hoisted_note.js\";\nimport options from \"../services/options.js\";\n\nclass NoteContext extends Component {\n    constructor(ntxId = null, hoistedNoteId = 'root', mainNtxId = null) {\n        super();\n\n        this.ntxId = ntxId || this.constructor.generateNtxId();\n        this.hoistedNoteId = hoistedNoteId;\n        this.mainNtxId = mainNtxId;\n\n        this.resetViewScope();\n    }\n\n    static generateNtxId() {\n        return utils.randomString(6);\n    }\n\n    setEmpty() {\n        this.notePath = null;\n        this.noteId = null;\n        this.parentNoteId = null;\n        // hoisted note is kept intentionally\n\n        this.triggerEvent('noteSwitched', {\n            noteContext: this,\n            notePath: this.notePath\n        });\n\n        this.resetViewScope();\n    }\n\n    isEmpty() {\n        return !this.noteId;\n    }\n\n    async setNote(inputNotePath, opts = {}) {\n        opts.triggerSwitchEvent = opts.triggerSwitchEvent !== undefined ? opts.triggerSwitchEvent : true;\n        opts.viewScope = opts.viewScope || {};\n        opts.viewScope.viewMode = opts.viewScope.viewMode || \"default\";\n\n        const resolvedNotePath = await this.getResolvedNotePath(inputNotePath);\n\n        if (!resolvedNotePath) {\n            return;\n        }\n\n        if (this.notePath === resolvedNotePath && utils.areObjectsEqual(this.viewScope, opts.viewScope)) {\n            return;\n        }\n\n        await this.triggerEvent('beforeNoteSwitch', {noteContext: this});\n\n        utils.closeActiveDialog();\n\n        this.notePath = resolvedNotePath;\n        this.viewScope = opts.viewScope;\n        ({noteId: this.noteId, parentNoteId: this.parentNoteId} = treeService.getNoteIdAndParentIdFromUrl(resolvedNotePath));\n\n        this.saveToRecentNotes(resolvedNotePath);\n\n        protectedSessionHolder.touchProtectedSessionIfNecessary(this.note);\n\n        if (opts.triggerSwitchEvent) {\n            await this.triggerEvent('noteSwitched', {\n                noteContext: this,\n                notePath: this.notePath\n            });\n        }\n\n        await this.setHoistedNoteIfNeeded();\n\n        if (utils.isMobile()) {\n            this.triggerCommand('setActiveScreen', {screen: 'detail'});\n        }\n    }\n\n    async setHoistedNoteIfNeeded() {\n        if (this.hoistedNoteId === 'root'\n            && this.notePath.startsWith(\"root/_hidden\")\n            && !this.note.isLabelTruthy(\"keepCurrentHoisting\")\n        ) {\n            // hidden subtree displays only when hoisted, so it doesn't make sense to keep root as hoisted note\n\n            let hoistedNoteId = '_hidden';\n\n            if (this.note.isLaunchBarConfig()) {\n                hoistedNoteId = '_lbRoot';\n            } else if (this.note.isOptions()) {\n                hoistedNoteId = '_options';\n            }\n\n            await this.setHoistedNoteId(hoistedNoteId);\n        }\n    }\n\n    getSubContexts() {\n        return appContext.tabManager.noteContexts.filter(nc => nc.ntxId === this.ntxId || nc.mainNtxId === this.ntxId);\n    }\n\n    /**\n     * A main context represents a tab and also the first split. Further splits are the children contexts of the main context.\n     * Imagine you have a tab with 3 splits, each showing notes A, B, C (in this order).\n     * In such a scenario, A context is the main context (also representing the tab as a whole), and B, C are the children\n     * of context A.\n     *\n     * @returns {boolean} true if the context is main (= tab)\n     */\n    isMainContext() {\n        // if null, then this is a main context\n        return !this.mainNtxId;\n    }\n\n    /**\n     * See docs for isMainContext() for better explanation.\n     *\n     * @returns {NoteContext}\n     */\n    getMainContext() {\n        if (this.mainNtxId) {\n            try {\n                return appContext.tabManager.getNoteContextById(this.mainNtxId);\n            }\n            catch (e) {\n                this.mainNtxId = null;\n                return this;\n            }\n        }\n        else {\n            return this;\n        }\n    }\n\n    saveToRecentNotes(resolvedNotePath) {\n        setTimeout(async () => {\n            // we include the note in the recent list only if the user stayed on the note at least 5 seconds\n            if (resolvedNotePath && resolvedNotePath === this.notePath) {\n                await server.post('recent-notes', {\n                    noteId: this.note.noteId,\n                    notePath: this.notePath\n                });\n            }\n        }, 5000);\n    }\n\n    async getResolvedNotePath(inputNotePath) {\n        const resolvedNotePath = await treeService.resolveNotePath(inputNotePath, this.hoistedNoteId);\n\n        if (!resolvedNotePath) {\n            logError(`Cannot resolve note path ${inputNotePath}`);\n            return;\n        }\n\n        if (await hoistedNoteService.checkNoteAccess(resolvedNotePath, this) === false) {\n            return; // note is outside of hoisted subtree and user chose not to unhoist\n        }\n\n        return resolvedNotePath;\n    }\n\n    /** @returns {FNote} */\n    get note() {\n        if (!this.noteId || !(this.noteId in froca.notes)) {\n            return null;\n        }\n\n        return froca.notes[this.noteId];\n    }\n\n    /** @returns {string[]} */\n    get notePathArray() {\n        return this.notePath ? this.notePath.split('/') : [];\n    }\n\n    isActive() {\n        return appContext.tabManager.activeNtxId === this.ntxId;\n    }\n\n    getPojoState() {\n        if (this.hoistedNoteId !== 'root') {\n            // keeping empty hoisted tab is esp. important for mobile (e.g. opened launcher config)\n\n            if (!this.notePath && this.getSubContexts().length === 0) {\n                return null;\n            }\n        }\n\n        return {\n            ntxId: this.ntxId,\n            mainNtxId: this.mainNtxId,\n            notePath: this.notePath,\n            hoistedNoteId: this.hoistedNoteId,\n            active: this.isActive(),\n            viewScope: this.viewScope\n        }\n    }\n\n    async unhoist() {\n        await this.setHoistedNoteId('root');\n    }\n\n    async setHoistedNoteId(noteIdToHoist) {\n        if (this.hoistedNoteId === noteIdToHoist) {\n            return;\n        }\n\n        this.hoistedNoteId = noteIdToHoist;\n\n        if (!this.notePathArray?.includes(noteIdToHoist) && !utils.isMobile()) {\n            await this.setNote(noteIdToHoist);\n        }\n\n        await this.triggerEvent('hoistedNoteChanged', {\n            noteId: noteIdToHoist,\n            ntxId: this.ntxId\n        });\n    }\n\n    /** @returns {Promise<boolean>} */\n    async isReadOnly() {\n        if (this.viewScope.readOnlyTemporarilyDisabled) {\n            return false;\n        }\n\n        // \"readOnly\" is a state valid only for text/code notes\n        if (!this.note || (this.note.type !== 'text' && this.note.type !== 'code')) {\n            return false;\n        }\n\n        if (this.note.isLabelTruthy('readOnly')) {\n            return true;\n        }\n\n        if (this.viewScope.viewMode === 'source') {\n            return true;\n        }\n\n        const blob = await this.note.getBlob();\n\n        const sizeLimit = this.note.type === 'text'\n            ? options.getInt('autoReadonlySizeText')\n            : options.getInt('autoReadonlySizeCode');\n\n        return blob.contentLength > sizeLimit\n            && !this.note.isLabelTruthy('autoReadOnlyDisabled');\n    }\n\n    async entitiesReloadedEvent({loadResults}) {\n        if (loadResults.isNoteReloaded(this.noteId)) {\n            const noteRow = loadResults.getEntityRow('notes', this.noteId);\n\n            if (noteRow.isDeleted) {\n                this.noteId = null;\n                this.notePath = null;\n\n                this.triggerEvent('noteSwitched', {\n                    noteContext: this,\n                    notePath: this.notePath\n                });\n            }\n        }\n    }\n\n    hasNoteList() {\n        return this.note\n            && this.viewScope.viewMode === 'default'\n            && this.note.hasChildren()\n            && ['book', 'text', 'code'].includes(this.note.type)\n            && this.note.mime !== 'text/x-sqlite;schema=trilium'\n            && !this.note.isLabelTruthy('hideChildrenOverview');\n    }\n\n    async getTextEditor(callback) {\n        return this.timeout(new Promise(resolve => appContext.triggerCommand('executeWithTextEditor', {\n            callback,\n            resolve,\n            ntxId: this.ntxId\n        })));\n    }\n\n    async getCodeEditor() {\n        return this.timeout(new Promise(resolve => appContext.triggerCommand('executeWithCodeEditor', {\n            resolve,\n            ntxId: this.ntxId\n        })));\n    }\n\n    async getContentElement() {\n        return this.timeout(new Promise(resolve => appContext.triggerCommand('executeWithContentElement', {\n            resolve,\n            ntxId: this.ntxId\n        })));\n    }\n\n    async getTypeWidget() {\n        return this.timeout(new Promise(resolve => appContext.triggerCommand('executeWithTypeWidget', {\n            resolve,\n            ntxId: this.ntxId\n        })));\n    }\n\n    timeout(promise) {\n        return Promise.race([\n            promise,\n            new Promise(res => setTimeout(() => res(null), 200))\n        ]);\n    }\n\n    resetViewScope() {\n        // view scope contains data specific to one note context and one \"view\".\n        // it is used to e.g., make read-only note temporarily editable or to hide TOC\n        // this is reset after navigating to a different note\n        this.viewScope = {};\n    }\n\n    async getNavigationTitle() {\n        if (!this.note) {\n            return null;\n        }\n\n        const { note, viewScope } = this;\n\n        let title = viewScope.viewMode === 'default'\n            ? note.title\n            : `${note.title}: ${viewScope.viewMode}`;\n\n        if (viewScope.attachmentId) {\n            // assuming the attachment has been already loaded\n            const attachment = await note.getAttachmentById(viewScope.attachmentId);\n\n            if (attachment) {\n                title += `: ${attachment.title}`;\n            }\n        }\n\n        return title;\n    }\n}\n\nexport default NoteContext;\n","export default class Mutex {\n    constructor() {\n        this.current = Promise.resolve();\n    }\n\n    /** @returns {Promise} */\n    lock() {\n        let resolveFun;\n        const subPromise = new Promise(resolve => resolveFun = () => resolve());\n        // Caller gets a promise that resolves when the current outstanding lock resolves\n        const newPromise = this.current.then(() => resolveFun);\n        // Don't allow the next request until the new promise is done\n        this.current = subPromise;\n        // Return the new promise\n        return newPromise;\n    };\n\n    async runExclusively(cb) {\n        const unlock = await this.lock();\n\n        try {\n            return await cb();\n        }\n        finally {\n            unlock();\n        }\n    }\n}\n","import Component from \"./component.js\";\nimport SpacedUpdate from \"../services/spaced_update.js\";\nimport server from \"../services/server.js\";\nimport options from \"../services/options.js\";\nimport froca from \"../services/froca.js\";\nimport treeService from \"../services/tree.js\";\nimport utils from \"../services/utils.js\";\nimport NoteContext from \"./note_context.js\";\nimport appContext from \"./app_context.js\";\nimport Mutex from \"../utils/mutex.js\";\nimport linkService from \"../services/link.js\";\n\nexport default class TabManager extends Component {\n    constructor() {\n        super();\n\n        /** @property {NoteContext[]} */\n        this.children = [];\n        this.mutex = new Mutex();\n\n        this.activeNtxId = null;\n\n        // elements are arrays of {contexts, position}, storing note contexts for each tab (one main context + subcontexts [splits]), and the original position of the tab\n        this.recentlyClosedTabs = [];\n\n        this.tabsUpdate = new SpacedUpdate(async () => {\n            if (!appContext.isMainWindow) {\n                return;\n            }\n\n            const openNoteContexts = this.noteContexts\n                .map(nc => nc.getPojoState())\n                .filter(t => !!t);\n\n            await server.put('options', {\n                openNoteContexts: JSON.stringify(openNoteContexts)\n            });\n        });\n\n        appContext.addBeforeUnloadListener(this);\n    }\n\n    /** @returns {NoteContext[]} */\n    get noteContexts() {\n        return this.children;\n    }\n\n    /** @type {NoteContext[]} */\n    get mainNoteContexts() {\n        return this.noteContexts.filter(nc => !nc.mainNtxId)\n    }\n\n    async loadTabs() {\n        try {\n            const noteContextsToOpen = (appContext.isMainWindow && options.getJson('openNoteContexts')) || [];\n\n            // preload all notes at once\n            await froca.getNotes([\n                    ...noteContextsToOpen.flatMap(tab =>\n                        [ treeService.getNoteIdFromUrl(tab.notePath), tab.hoistedNoteId]\n                    ),\n            ], true);\n\n            const filteredNoteContexts = noteContextsToOpen.filter(openTab => {\n                if (utils.isMobile()) { // mobile frontend doesn't have tabs so show only the active tab\n                    return !!openTab.active;\n                }\n\n                const noteId = treeService.getNoteIdFromUrl(openTab.notePath);\n                if (!(noteId in froca.notes)) {\n                    // note doesn't exist so don't try to open tab for it\n                    return false;\n                }\n\n                if (!(openTab.hoistedNoteId in froca.notes)) {\n                    openTab.hoistedNoteId = 'root';\n                }\n\n                return true;\n            });\n\n            // resolve before opened tabs can change this\n            const parsedFromUrl = linkService.parseNavigationStateFromUrl(window.location.href);\n\n            if (filteredNoteContexts.length === 0) {\n                parsedFromUrl.ntxId = parsedFromUrl.ntxId || NoteContext.generateNtxId(); // generate already here, so that we later know which one to activate\n\n                filteredNoteContexts.push({\n                    notePath: parsedFromUrl.notePath || 'root',\n                    ntxId: parsedFromUrl.ntxId,\n                    active: true,\n                    hoistedNoteId: parsedFromUrl.hoistedNoteId || 'root',\n                    viewScope: parsedFromUrl.viewScope || {}\n                });\n            } else if (!filteredNoteContexts.find(tab => tab.active)) {\n                filteredNoteContexts[0].active = true;\n            }\n\n            await this.tabsUpdate.allowUpdateWithoutChange(async () => {\n                for (const tab of filteredNoteContexts) {\n                    await this.openContextWithNote(tab.notePath, {\n                        activate: tab.active,\n                        ntxId: tab.ntxId,\n                        mainNtxId: tab.mainNtxId,\n                        hoistedNoteId: tab.hoistedNoteId,\n                        viewScope: tab.viewScope\n                    });\n                }\n            });\n\n            // if there's a notePath in the URL, make sure it's open and active\n            // (useful, for e.g., opening clipped notes from clipper or opening link in an extra window)\n            if (parsedFromUrl.notePath) {\n                await appContext.tabManager.switchToNoteContext(\n                    parsedFromUrl.ntxId,\n                    parsedFromUrl.notePath,\n                    parsedFromUrl.viewScope,\n                    parsedFromUrl.hoistedNoteId\n                );\n            } else if (parsedFromUrl.searchString) {\n                await appContext.triggerCommand('searchNotes', {\n                    searchString: parsedFromUrl.searchString\n                });\n            }\n        }\n        catch (e) {\n            logError(`Loading note contexts '${options.get('openNoteContexts')}' failed: ${e.message} ${e.stack}`);\n\n            // try to recover\n            await this.openEmptyTab();\n        }\n    }\n\n    noteSwitchedEvent({noteContext}) {\n        if (noteContext.isActive()) {\n            this.setCurrentNavigationStateToHash();\n        }\n\n        this.tabsUpdate.scheduleUpdate();\n    }\n\n    setCurrentNavigationStateToHash() {\n        const calculatedHash = this.calculateHash();\n\n        // update if it's the first history entry or there has been a change\n        if (window.history.length === 0 || calculatedHash !== window.location?.hash) {\n            // using pushState instead of directly modifying document.location because it does not trigger hashchange\n            window.history.pushState(null, \"\", calculatedHash);\n        }\n\n        const activeNoteContext = this.getActiveContext();\n        this.updateDocumentTitle(activeNoteContext);\n\n        this.triggerEvent('activeNoteChanged'); // trigger this even in on popstate event\n    }\n\n    calculateHash() {\n        const activeNoteContext = this.getActiveContext();\n        if (!activeNoteContext) {\n            return \"\";\n        }\n\n        return linkService.calculateHash({\n            notePath: activeNoteContext.notePath,\n            ntxId: activeNoteContext.ntxId,\n            hoistedNoteId: activeNoteContext.hoistedNoteId,\n            viewScope: activeNoteContext.viewScope\n        });\n    }\n\n    /** @returns {NoteContext[]} */\n    getNoteContexts() {\n        return this.noteContexts;\n    }\n\n    /**\n     * Main context is essentially a tab (children are splits), so this returns tabs.\n     * @returns {NoteContext[]}\n     */\n    getMainNoteContexts() {\n        return this.noteContexts.filter(nc => nc.isMainContext());\n    }\n\n    /** @returns {NoteContext} */\n    getNoteContextById(ntxId) {\n        const noteContext = this.noteContexts.find(nc => nc.ntxId === ntxId);\n\n        if (!noteContext) {\n            throw new Error(`Cannot find noteContext id='${ntxId}'`);\n        }\n\n        return noteContext;\n    }\n\n    /**\n     * Get active context which represents the visible split with focus. Active context can, but doesn't have to be \"main\".\n     *\n     * @returns {NoteContext}\n     */\n    getActiveContext() {\n        return this.activeNtxId\n            ? this.getNoteContextById(this.activeNtxId)\n            : null;\n    }\n\n    /**\n     * Get active main context which corresponds to the active tab.\n     *\n     * @returns {NoteContext}\n     */\n    getActiveMainContext() {\n        return this.activeNtxId\n            ? this.getNoteContextById(this.activeNtxId).getMainContext()\n            : null;\n    }\n\n    /** @returns {string|null} */\n    getActiveContextNotePath() {\n        const activeContext = this.getActiveContext();\n        return activeContext ? activeContext.notePath : null;\n    }\n\n    /** @returns {FNote} */\n    getActiveContextNote() {\n        const activeContext = this.getActiveContext();\n        return activeContext ? activeContext.note : null;\n    }\n\n    /** @returns {string|null} */\n    getActiveContextNoteId() {\n        const activeNote = this.getActiveContextNote();\n\n        return activeNote ? activeNote.noteId : null;\n    }\n\n    /** @returns {string|null} */\n    getActiveContextNoteType() {\n        const activeNote = this.getActiveContextNote();\n\n        return activeNote ? activeNote.type : null;\n    }\n    /** @returns {string|null} */\n    getActiveContextNoteMime() {\n        const activeNote = this.getActiveContextNote();\n\n        return activeNote ? activeNote.mime : null;\n    }\n\n    async switchToNoteContext(ntxId, notePath, viewScope = {}, hoistedNoteId = null) {\n        const noteContext = this.noteContexts.find(nc => nc.ntxId === ntxId)\n            || await this.openEmptyTab();\n\n        await this.activateNoteContext(noteContext.ntxId);\n\n        if (hoistedNoteId) {\n            await noteContext.setHoistedNoteId(hoistedNoteId);\n        }\n\n        if (notePath) {\n            await noteContext.setNote(notePath, { viewScope });\n        }\n    }\n\n    async openAndActivateEmptyTab() {\n        const noteContext = await this.openEmptyTab();\n\n        await this.activateNoteContext(noteContext.ntxId);\n\n        await noteContext.setEmpty();\n    }\n\n    async openEmptyTab(ntxId = null, hoistedNoteId = 'root', mainNtxId = null) {\n        const noteContext = new NoteContext(ntxId, hoistedNoteId, mainNtxId);\n\n        let existingNoteContext;\n\n        if (utils.isMobile()) {\n            // kind of hacky way to enforce a single tab on mobile interface - all requests to create a new one\n            // are forced to reuse the existing ab instead\n            existingNoteContext = this.getActiveContext();\n        } else {\n            existingNoteContext = this.children.find(nc => nc.ntxId === noteContext.ntxId);\n        }\n\n        if (existingNoteContext) {\n            await existingNoteContext.setHoistedNoteId(hoistedNoteId);\n\n            return existingNoteContext;\n        }\n\n        this.child(noteContext);\n\n        await this.triggerEvent('newNoteContextCreated', {noteContext});\n\n        return noteContext;\n    }\n\n    async openInNewTab(targetNoteId, hoistedNoteId = null) {\n        const noteContext = await this.openEmptyTab(null, hoistedNoteId || this.getActiveContext().hoistedNoteId);\n\n        await noteContext.setNote(targetNoteId);\n    }\n\n    async openInSameTab(targetNoteId, hoistedNoteId = null) {\n        const activeContext = this.getActiveContext();\n        await activeContext.setHoistedNoteId(hoistedNoteId || activeContext.hoistedNoteId);\n        await activeContext.setNote(targetNoteId);\n    }\n\n    /**\n     * If the requested notePath is within current note hoisting scope then keep the note hoisting also for the new tab.\n     */\n    async openTabWithNoteWithHoisting(notePath, opts = {}) {\n        const noteContext = this.getActiveContext();\n        let hoistedNoteId = 'root';\n\n        if (noteContext) {\n            const resolvedNotePath = await treeService.resolveNotePath(notePath, noteContext.hoistedNoteId);\n\n            if (resolvedNotePath.includes(noteContext.hoistedNoteId) || resolvedNotePath.includes('_hidden')) {\n                hoistedNoteId = noteContext.hoistedNoteId;\n            }\n        }\n\n        opts.hoistedNoteId = hoistedNoteId;\n\n        return this.openContextWithNote(notePath, opts);\n    }\n\n    async openContextWithNote(notePath, opts = {}) {\n        const activate = !!opts.activate;\n        const ntxId = opts.ntxId || null;\n        const mainNtxId = opts.mainNtxId || null;\n        const hoistedNoteId = opts.hoistedNoteId || 'root';\n        const viewScope = opts.viewScope || { viewMode: \"default\" };\n\n        const noteContext = await this.openEmptyTab(ntxId, hoistedNoteId, mainNtxId);\n\n        if (notePath) {\n            await noteContext.setNote(notePath, {\n                // if activate is false, then send normal noteSwitched event\n                triggerSwitchEvent: !activate,\n                viewScope: viewScope\n            });\n        }\n\n        if (activate) {\n            this.activateNoteContext(noteContext.ntxId, false);\n\n            await this.triggerEvent('noteSwitchedAndActivated', {\n                noteContext,\n                notePath: noteContext.notePath // resolved note path\n            });\n        }\n\n        return noteContext;\n    }\n\n    async activateOrOpenNote(noteId) {\n        for (const noteContext of this.getNoteContexts()) {\n            if (noteContext.note && noteContext.note.noteId === noteId) {\n                this.activateNoteContext(noteContext.ntxId);\n\n                return;\n            }\n        }\n\n        // if no tab with this note has been found we'll create new tab\n\n        await this.openContextWithNote(noteId, { activate: true });\n    }\n\n    async activateNoteContext(ntxId, triggerEvent = true) {\n        if (ntxId === this.activeNtxId) {\n            return;\n        }\n\n        this.activeNtxId = ntxId;\n\n        if (triggerEvent) {\n            await this.triggerEvent('activeContextChanged', {\n                noteContext: this.getNoteContextById(ntxId)\n            });\n        }\n\n        this.tabsUpdate.scheduleUpdate();\n\n        this.setCurrentNavigationStateToHash();\n    }\n\n    /**\n     * @param ntxId\n     * @returns {Promise<boolean>} true if note context has been removed, false otherwise\n     */\n    async removeNoteContext(ntxId) {\n        // removing note context is an async process which can take some time, if users presses CTRL-W quickly, two\n        // close events could interleave which would then lead to attempting to activate already removed context.\n        return await this.mutex.runExclusively(async () => {\n            let noteContextToRemove;\n\n            try {\n                noteContextToRemove = this.getNoteContextById(ntxId);\n            }\n            catch {\n                // note context not found\n                return false;\n            }\n\n            if (noteContextToRemove.isMainContext()) {\n                const mainNoteContexts = this.getNoteContexts().filter(nc => nc.isMainContext());\n\n                if (mainNoteContexts.length === 1) {\n                    if (noteContextToRemove.isEmpty()) {\n                        // this is already the empty note context, no point in closing it and replacing with another\n                        // empty tab\n                        return false;\n                    }\n\n                    await this.openEmptyTab();\n                }\n            }\n\n            // close dangling autocompletes after closing the tab\n            $(\".aa-input\").autocomplete(\"close\");\n\n            const noteContextsToRemove = noteContextToRemove.getSubContexts();\n            const ntxIdsToRemove = noteContextsToRemove.map(nc => nc.ntxId);\n\n            await this.triggerEvent('beforeNoteContextRemove', { ntxIds: ntxIdsToRemove });\n\n            if (!noteContextToRemove.isMainContext()) {\n                const siblings = noteContextToRemove.getMainContext().getSubContexts();\n                const idx = siblings.findIndex(nc => nc.ntxId === noteContextToRemove.ntxId);\n                const contextToActivateIdx = idx === siblings.length - 1 ? idx - 1 : idx + 1;\n                const contextToActivate = siblings[contextToActivateIdx];\n\n                await this.activateNoteContext(contextToActivate.ntxId);\n            }\n            else if (this.mainNoteContexts.length <= 1) {\n                await this.openAndActivateEmptyTab();\n            }\n            else if (ntxIdsToRemove.includes(this.activeNtxId)) {\n                const idx = this.mainNoteContexts.findIndex(nc => nc.ntxId === noteContextToRemove.ntxId);\n\n                if (idx === this.mainNoteContexts.length - 1) {\n                    await this.activatePreviousTabCommand();\n                }\n                else {\n                    await this.activateNextTabCommand();\n                }\n            }\n\n            this.removeNoteContexts(noteContextsToRemove);\n\n            return true;\n        });\n    }\n\n    removeNoteContexts(noteContextsToRemove) {\n        const ntxIdsToRemove = noteContextsToRemove.map(nc => nc.ntxId);\n\n        const position = this.noteContexts.findIndex(nc => ntxIdsToRemove.includes(nc.ntxId));\n\n        this.children = this.children.filter(nc => !ntxIdsToRemove.includes(nc.ntxId));\n\n        this.addToRecentlyClosedTabs(noteContextsToRemove, position);\n\n        this.triggerEvent('noteContextRemoved', {ntxIds: ntxIdsToRemove});\n\n        this.tabsUpdate.scheduleUpdate();\n    }\n\n    addToRecentlyClosedTabs(noteContexts, position) {\n        if (noteContexts.length === 1 && noteContexts[0].isEmpty()) {\n            return;\n        }\n\n        this.recentlyClosedTabs.push({contexts: noteContexts, position: position});\n    }\n\n    tabReorderEvent({ntxIdsInOrder}) {\n        const order = {};\n\n        let i = 0;\n\n        for (const ntxId of ntxIdsInOrder) {\n            for (const noteContext of this.getNoteContextById(ntxId).getSubContexts()) {\n                order[noteContext.ntxId] = i++;\n            }\n        }\n\n        this.children.sort((a, b) => order[a.ntxId] < order[b.ntxId] ? -1 : 1);\n\n        this.tabsUpdate.scheduleUpdate();\n    }\n\n    noteContextReorderEvent({ntxIdsInOrder, oldMainNtxId, newMainNtxId}) {\n        const order = Object.fromEntries(ntxIdsInOrder.map((v, i) => [v, i]));\n\n        this.children.sort((a, b) => order[a.ntxId] < order[b.ntxId] ? -1 : 1);\n\n        if (oldMainNtxId && newMainNtxId) {\n            this.children.forEach(c => {\n                if (c.ntxId === newMainNtxId) {\n                    // new main context has null mainNtxId\n                    c.mainNtxId = null;\n                } else if (c.ntxId === oldMainNtxId || c.mainNtxId === oldMainNtxId) {\n                    // old main context or subcontexts all have the new mainNtxId\n                    c.mainNtxId = newMainNtxId;\n                }\n            });\n        }\n\n        this.tabsUpdate.scheduleUpdate();\n    }\n\n    async activateNextTabCommand() {\n        const activeMainNtxId = this.getActiveMainContext().ntxId;\n\n        const oldIdx = this.mainNoteContexts.findIndex(nc => nc.ntxId === activeMainNtxId);\n        const newActiveNtxId = this.mainNoteContexts[oldIdx === this.mainNoteContexts.length - 1 ? 0 : oldIdx + 1].ntxId;\n\n        await this.activateNoteContext(newActiveNtxId);\n    }\n\n    async activatePreviousTabCommand() {\n        const activeMainNtxId = this.getActiveMainContext().ntxId;\n\n        const oldIdx = this.mainNoteContexts.findIndex(nc => nc.ntxId === activeMainNtxId);\n        const newActiveNtxId = this.mainNoteContexts[oldIdx === 0 ? this.mainNoteContexts.length - 1 : oldIdx - 1].ntxId;\n\n        await this.activateNoteContext(newActiveNtxId);\n    }\n\n    async closeActiveTabCommand() {\n        await this.removeNoteContext(this.activeNtxId);\n    }\n\n    beforeUnloadEvent() {\n        this.tabsUpdate.updateNowIfNecessary();\n\n        return true; // don't block closing the tab, this metadata is not that important\n    }\n\n    openNewTabCommand() {\n        this.openAndActivateEmptyTab();\n    }\n\n    async closeAllTabsCommand() {\n        for (const ntxIdToRemove of this.mainNoteContexts.map(nc => nc.ntxId)) {\n            await this.removeNoteContext(ntxIdToRemove);\n        }\n    }\n\n    async closeOtherTabsCommand({ntxId}) {\n        for (const ntxIdToRemove of this.mainNoteContexts.map(nc => nc.ntxId)) {\n            if (ntxIdToRemove !== ntxId) {\n                await this.removeNoteContext(ntxIdToRemove);\n            }\n        }\n    }\n\n    async closeTabCommand({ntxId}) {\n        await this.removeNoteContext(ntxId);\n    }\n\n    async moveTabToNewWindowCommand({ntxId}) {\n        const {notePath, hoistedNoteId} = this.getNoteContextById(ntxId);\n\n        const removed = await this.removeNoteContext(ntxId);\n\n        if (removed) {\n            this.triggerCommand('openInWindow', {notePath, hoistedNoteId});\n        }\n    }\n\n    async reopenLastTabCommand() {\n        let closeLastEmptyTab = null;\n\n        await this.mutex.runExclusively(async () => {\n            if (this.recentlyClosedTabs.length === 0) {\n                return;\n            }\n\n            if (this.noteContexts.length === 1 && this.noteContexts[0].isEmpty()) {\n                // new empty tab is created after closing the last tab, this reverses the empty tab creation\n                closeLastEmptyTab = this.noteContexts[0];\n            }\n\n            const lastClosedTab = this.recentlyClosedTabs.pop();\n            const noteContexts = lastClosedTab.contexts;\n\n            for (const noteContext of noteContexts) {\n                this.child(noteContext);\n\n                await this.triggerEvent('newNoteContextCreated', {noteContext});\n            }\n\n            //  restore last position of contexts stored in tab manager\n            const ntxsInOrder = [\n                ...this.noteContexts.slice(0, lastClosedTab.position),\n                ...this.noteContexts.slice(-noteContexts.length),\n                ...this.noteContexts.slice(lastClosedTab.position, -noteContexts.length),\n            ]\n            await this.noteContextReorderEvent({ntxIdsInOrder: ntxsInOrder.map(nc => nc.ntxId)});\n\n            let mainNtx = noteContexts.find(nc => nc.isMainContext());\n            if (mainNtx) {\n                // reopened a tab, need to reorder new tab widget in tab row\n                await this.triggerEvent('contextsReopened', {\n                    mainNtxId: mainNtx.ntxId,\n                    tabPosition: ntxsInOrder.filter(nc => nc.isMainContext()).findIndex(nc => nc.ntxId === mainNtx.ntxId)\n                });\n            } else {\n                // reopened a single split, need to reorder the pane widget in split note container\n                await this.triggerEvent('contextsReopened', {\n                    ntxId: ntxsInOrder[lastClosedTab.position].ntxId,\n                    // this is safe since lastClosedTab.position can never be 0 in this case\n                    afterNtxId: ntxsInOrder[lastClosedTab.position - 1].ntxId\n                });\n            }\n\n            const noteContextToActivate = noteContexts.length === 1\n                ? noteContexts[0]\n                : noteContexts.find(nc => nc.isMainContext());\n\n            await this.activateNoteContext(noteContextToActivate.ntxId);\n\n            await this.triggerEvent('noteSwitched', {\n                noteContext: noteContextToActivate,\n                notePath: noteContextToActivate.notePath\n            });\n        });\n\n        if (closeLastEmptyTab) {\n            await this.removeNoteContext(closeLastEmptyTab.ntxId);\n        }\n    }\n\n    hoistedNoteChangedEvent() {\n        this.tabsUpdate.scheduleUpdate();\n    }\n\n    async updateDocumentTitle(activeNoteContext) {\n        const titleFragments = [\n            // it helps to navigate in history if note title is included in the title\n            await activeNoteContext.getNavigationTitle(),\n            \"Trilium Notes\"\n        ].filter(Boolean);\n\n        document.title = titleFragments.join(\" - \");\n    }\n\n    async entitiesReloadedEvent({loadResults}) {\n        const activeContext = this.getActiveContext();\n\n        if (activeContext && loadResults.isNoteReloaded(activeContext.noteId)) {\n            await this.updateDocumentTitle(activeContext);\n        }\n    }\n\n    async frocaReloadedEvent() {\n        const activeContext = this.getActiveContext();\n\n        if (activeContext) {\n            await this.updateDocumentTitle(activeContext);\n        }\n    }\n}\n","import Component from \"./component.js\";\nimport appContext from \"./app_context.js\";\n\nexport default class MobileScreenSwitcherExecutor extends Component {\n    setActiveScreenCommand({screen}) {\n        if (screen !== this.activeScreen) {\n            this.activeScreen = screen;\n\n            if (screen === 'tree') {\n                const activeNoteContext = appContext.tabManager.getActiveContext();\n\n                activeNoteContext.setEmpty();\n            }\n\n            this.triggerEvent('activeScreenChanged', {activeScreen: screen});\n        }\n    }\n}\n","import appContext from \"./app_context.js\";\nimport noteCreateService from \"../services/note_create.js\";\nimport treeService from \"../services/tree.js\";\nimport hoistedNoteService from \"../services/hoisted_note.js\";\nimport Component from \"./component.js\";\n\n/**\n * This class contains command executors which logically belong to the NoteTree widget, but for better user experience,\n * the keyboard shortcuts must be active on the whole screen and not just on the widget itself, so the executors\n * must be at the root of the component tree.\n */\nexport default class MainTreeExecutors extends Component {\n    get tree() {\n        return appContext.noteTreeWidget;\n    }\n\n    async cloneNotesToCommand() {\n        const selectedOrActiveNoteIds = this.tree.getSelectedOrActiveNodes().map(node => node.data.noteId);\n\n        this.triggerCommand('cloneNoteIdsTo', {noteIds: selectedOrActiveNoteIds});\n    }\n\n    async moveNotesToCommand() {\n        const selectedOrActiveBranchIds = this.tree.getSelectedOrActiveNodes().map(node => node.data.branchId);\n\n        this.triggerCommand('moveBranchIdsTo', {branchIds: selectedOrActiveBranchIds});\n    }\n\n    async createNoteIntoCommand() {\n        const activeNoteContext = appContext.tabManager.getActiveContext();\n\n        if (!activeNoteContext) {\n            return;\n        }\n\n        await noteCreateService.createNote(activeNoteContext.notePath, {\n            isProtected: activeNoteContext.note.isProtected,\n            saveSelection: false\n        });\n    }\n\n    async createNoteAfterCommand() {\n        const node = this.tree.getActiveNode();\n\n        if (!node) {\n            return;\n        }\n\n        const parentNotePath = treeService.getNotePath(node.getParent());\n        const isProtected = treeService.getParentProtectedStatus(node);\n\n        if (node.data.noteId === 'root' || node.data.noteId === hoistedNoteService.getHoistedNoteId()) {\n            return;\n        }\n\n        await noteCreateService.createNote(parentNotePath, {\n            target: 'after',\n            targetBranchId: node.data.branchId,\n            isProtected: isProtected,\n            saveSelection: false\n        });\n    }\n}\n","import appContext from \"./app_context.js\";\nimport shortcutService from \"../services/shortcuts.js\";\nimport server from \"../services/server.js\";\nimport Component from \"./component.js\";\nimport froca from \"../services/froca.js\";\n\nexport default class ShortcutComponent extends Component {\n    constructor() {\n        super();\n\n        server.get('keyboard-shortcuts-for-notes').then(shortcutAttributes => {\n            for (const attr of shortcutAttributes) {\n                this.bindNoteShortcutHandler(attr);\n            }\n        });\n    }\n\n    bindNoteShortcutHandler(labelOrRow) {\n        const handler = () => appContext.tabManager.getActiveContext().setNote(labelOrRow.noteId);\n        const namespace = labelOrRow.attributeId;\n\n        if (labelOrRow.isDeleted) { // only applicable if row\n            shortcutService.removeGlobalShortcut(namespace);\n        } else {\n            shortcutService.bindGlobalShortcut(labelOrRow.value, handler, namespace);\n        }\n    }\n\n    async entitiesReloadedEvent({loadResults}) {\n        for (const attr of loadResults.getAttributeRows()) {\n            if (attr.type === 'label' && attr.name === 'keyboardShortcut') {\n                const note = await froca.getNote(attr.noteId);\n                // launcher shortcuts are handled specifically\n                if (note && note.type !== 'launcher') {\n                    this.bindNoteShortcutHandler(attr);\n                }\n            }\n        }\n    }\n}\n","import froca from \"../services/froca.js\";\nimport bundleService from \"../services/bundle.js\";\nimport RootCommandExecutor from \"./root_command_executor.js\";\nimport Entrypoints from \"./entrypoints.js\";\nimport options from \"../services/options.js\";\nimport utils from \"../services/utils.js\";\nimport zoomComponent from \"./zoom.js\";\nimport TabManager from \"./tab_manager.js\";\nimport Component from \"./component.js\";\nimport keyboardActionsService from \"../services/keyboard_actions.js\";\nimport linkService from \"../services/link.js\";\nimport MobileScreenSwitcherExecutor from \"./mobile_screen_switcher.js\";\nimport MainTreeExecutors from \"./main_tree_executors.js\";\nimport toast from \"../services/toast.js\";\nimport ShortcutComponent from \"./shortcut_component.js\";\n\nclass AppContext extends Component {\n    constructor(isMainWindow) {\n        super();\n\n        this.isMainWindow = isMainWindow;\n        // non-widget/layout components needed for the application\n        this.components = [];\n        this.beforeUnloadListeners = [];\n    }\n\n    setLayout(layout) {\n        this.layout = layout;\n    }\n\n    async start() {\n        this.initComponents();\n\n        // options are often needed for isEnabled()\n        await options.initializedPromise;\n\n        this.renderWidgets();\n\n        await froca.initializedPromise;\n\n        this.tabManager.loadTabs();\n\n        setTimeout(() => bundleService.executeStartupBundles(), 2000);\n    }\n\n    initComponents() {\n        this.tabManager = new TabManager();\n\n        this.components = [\n            this.tabManager,\n            new RootCommandExecutor(),\n            new Entrypoints(),\n            new MainTreeExecutors(),\n            new ShortcutComponent()\n        ];\n\n        if (utils.isMobile()) {\n            this.components.push(new MobileScreenSwitcherExecutor());\n        }\n\n        for (const component of this.components) {\n            this.child(component);\n        }\n\n        if (utils.isElectron()) {\n            this.child(zoomComponent);\n        }\n    }\n\n    renderWidgets() {\n        const rootWidget = this.layout.getRootWidget(this);\n        const $renderedWidget = rootWidget.render();\n\n        keyboardActionsService.updateDisplayedShortcuts($renderedWidget);\n\n        $(\"body\").append($renderedWidget);\n\n        $renderedWidget.on('click', \"[data-trigger-command]\", function() {\n            if ($(this).hasClass(\"disabled\")) {\n                return;\n            }\n\n            const commandName = $(this).attr('data-trigger-command');\n            const $component = $(this).closest(\".component\");\n            const component = $component.prop(\"component\");\n\n            component.triggerCommand(commandName, {$el: $(this)});\n        });\n\n        this.child(rootWidget);\n\n        this.triggerEvent('initialRenderComplete');\n    }\n\n    /** @returns {Promise<void>} */\n    triggerEvent(name, data = {}) {\n        return this.handleEvent(name, data);\n    }\n\n    /** @returns {Promise<*>} */\n    triggerCommand(name, data = {}) {\n        for (const executor of this.components) {\n            const fun = executor[`${name}Command`];\n\n            if (fun) {\n                return executor.callMethod(fun, data);\n            }\n        }\n\n        // this might hint at error, but sometimes this is used by components which are at different places\n        // in the component tree to communicate with each other\n        console.debug(`Unhandled command ${name}, converting to event.`);\n\n        return this.triggerEvent(name, data);\n    }\n\n    getComponentByEl(el) {\n        return $(el).closest(\".component\").prop('component');\n    }\n\n    addBeforeUnloadListener(obj) {\n        if (typeof WeakRef !== \"function\") {\n            // older browsers don't support WeakRef\n            return;\n        }\n\n        this.beforeUnloadListeners.push(new WeakRef(obj));\n    }\n}\n\nconst appContext = new AppContext(window.glob.isMainWindow);\n\n// we should save all outstanding changes before the page/app is closed\n$(window).on('beforeunload', () => {\n    let allSaved = true;\n\n    appContext.beforeUnloadListeners = appContext.beforeUnloadListeners.filter(wr => !!wr.deref());\n\n    for (const weakRef of appContext.beforeUnloadListeners) {\n        const component = weakRef.deref();\n\n        if (!component) {\n            continue;\n        }\n\n        if (!component.beforeUnloadEvent()) {\n            console.log(`Component ${component.componentId} is not finished saving its state.`);\n\n            toast.showMessage(\"Please wait for a couple of seconds for the save to finish, then you can try again.\", 10000);\n\n            allSaved = false;\n        }\n    }\n\n    if (!allSaved) {\n        return \"some string\";\n    }\n});\n\n$(window).on('hashchange', function() {\n    const {notePath, ntxId, viewScope} = linkService.parseNavigationStateFromUrl(window.location.href);\n\n    if (notePath || ntxId) {\n        appContext.tabManager.switchToNoteContext(ntxId, notePath, viewScope);\n    }\n});\n\nexport default appContext;\n","import utils from '../services/utils.js';\n\n/**\n * Abstract class for all components in the Trilium's frontend.\n *\n * Contains also event implementation with following properties:\n * - event / command distribution is synchronous which among others mean that events are well-ordered - event\n *   which was sent out first will also be processed first by the component\n * - execution of the event / command is asynchronous - each component executes the event on its own without regard for\n *   other components.\n * - although the execution is async, we are collecting all the promises, and therefore it is possible to wait until the\n *   event / command is executed in all components - by simply awaiting the `triggerEvent()`.\n */\nexport default class Component {\n    constructor() {\n        this.componentId = `${this.sanitizedClassName}-${utils.randomString(8)}`;\n        /** @type Component[] */\n        this.children = [];\n        this.initialized = null;\n    }\n\n    get sanitizedClassName() {\n        // webpack mangles names and sometimes uses unsafe characters\n        return this.constructor.name.replace(/[^A-Z0-9]/ig, \"_\");\n    }\n\n    setParent(parent) {\n        /** @type Component */\n        this.parent = parent;\n        return this;\n    }\n\n    child(...components) {\n        for (const component of components) {\n            component.setParent(this);\n\n            this.children.push(component);\n        }\n\n        return this;\n    }\n\n    /** @returns {Promise<void>} */\n    handleEvent(name, data) {\n        try {\n            const callMethodPromise = this.initialized\n                ? this.initialized.then(() => this.callMethod(this[`${name}Event`], data))\n                : this.callMethod(this[`${name}Event`], data);\n\n            const childrenPromise = this.handleEventInChildren(name, data);\n\n            // don't create promises if not needed (optimization)\n            return callMethodPromise && childrenPromise\n                ? Promise.all([callMethodPromise, childrenPromise])\n                : (callMethodPromise || childrenPromise);\n        }\n        catch (e) {\n            console.error(`Handling of event '${name}' failed in ${this.constructor.name} with error ${e.message} ${e.stack}`);\n\n            return null;\n        }\n    }\n\n    /** @returns {Promise<void>} */\n    triggerEvent(name, data = {}) {\n        return this.parent.triggerEvent(name, data);\n    }\n\n    /** @returns {Promise<void>} */\n    handleEventInChildren(name, data = {}) {\n        const promises = [];\n\n        for (const child of this.children) {\n            const ret = child.handleEvent(name, data);\n\n            if (ret) {\n                promises.push(ret);\n            }\n        }\n\n        // don't create promises if not needed (optimization)\n        return promises.length > 0 ? Promise.all(promises) : null;\n    }\n\n    /** @returns {Promise<*>} */\n    triggerCommand(name, data = {}) {\n        const fun = this[`${name}Command`];\n\n        if (fun) {\n            return this.callMethod(fun, data);\n        }\n        else {\n            return this.parent.triggerCommand(name, data);\n        }\n    }\n\n    callMethod(fun, data) {\n        if (typeof fun !== 'function') {\n            return;\n        }\n\n        const startTime = Date.now();\n\n        const promise = fun.call(this, data);\n\n        const took = Date.now() - startTime;\n\n        if (glob.isDev && took > 20) { // measuring only sync handlers\n            console.log(`Call to ${fun.name} in ${this.componentId} took ${took}ms`);\n        }\n\n        if (glob.isDev && promise) {\n            return utils.timeLimit(promise, 20000, `Time limit failed on ${this.constructor.name} with ${fun.name}`);\n        }\n\n        return promise;\n    }\n}\n","import options from \"../services/options.js\";\nimport Component from \"./component.js\";\nimport utils from \"../services/utils.js\";\n\nconst MIN_ZOOM = 0.5;\nconst MAX_ZOOM = 2.0;\n\nclass ZoomComponent extends Component {\n    constructor() {\n        super();\n\n        if (utils.isElectron()) {\n            options.initializedPromise.then(() => {\n                this.setZoomFactor(options.getFloat('zoomFactor'));\n            });\n\n            window.addEventListener(\"wheel\", event => {\n                if (event.ctrlKey) {\n                    this.setZoomFactorAndSave(this.getCurrentZoom() + event.deltaY * 0.001);\n                }\n            });\n        }\n    }\n\n    setZoomFactor(zoomFactor) {\n        zoomFactor = parseFloat(zoomFactor);\n\n        const webFrame = utils.dynamicRequire('electron').webFrame;\n        webFrame.setZoomFactor(zoomFactor);\n    }\n\n    async setZoomFactorAndSave(zoomFactor) {\n        if (zoomFactor >= MIN_ZOOM && zoomFactor <= MAX_ZOOM) {\n            zoomFactor = Math.round(zoomFactor * 10) / 10;\n\n            this.setZoomFactor(zoomFactor);\n\n            await options.save('zoomFactor', zoomFactor);\n        }\n        else {\n            console.log(`Zoom factor ${zoomFactor} outside of the range, ignored.`);\n        }\n    }\n\n    getCurrentZoom() {\n        return utils.dynamicRequire('electron').webFrame.getZoomFactor();\n    }\n\n    zoomOutEvent() {\n        this.setZoomFactorAndSave(this.getCurrentZoom() - 0.1);\n    }\n\n    zoomInEvent() {\n        this.setZoomFactorAndSave(this.getCurrentZoom() + 0.1);\n    }\n    zoomResetEvent() {\n        this.setZoomFactorAndSave(1);\n    }\n    \n    setZoomFactorAndSaveEvent({zoomFactor}) {\n        this.setZoomFactorAndSave(zoomFactor);\n    }\n}\n\nconst zoomService = new ZoomComponent();\n\nexport default zoomService;\n","/**\n * Attachment is a file directly tied into a note without\n * being a hidden child.\n */\nclass FAttachment {\n    constructor(froca, row) {\n        /** @type {Froca} */\n        this.froca = froca;\n\n        this.update(row);\n    }\n\n    update(row) {\n        /** @type {string} */\n        this.attachmentId = row.attachmentId;\n        /** @type {string} */\n        this.ownerId = row.ownerId;\n        /** @type {string} */\n        this.role = row.role;\n        /** @type {string} */\n        this.mime = row.mime;\n        /** @type {string} */\n        this.title = row.title;\n        /** @type {string} */\n        this.dateModified = row.dateModified;\n        /** @type {string} */\n        this.utcDateModified = row.utcDateModified;\n        /** @type {string} */\n        this.utcDateScheduledForErasureSince = row.utcDateScheduledForErasureSince;\n\n        /**\n         * optionally added to the entity \n         * @type {int}\n         */\n        this.contentLength = row.contentLength;\n\n        this.froca.attachments[this.attachmentId] = this;\n    }\n\n    /** @returns {FNote} */\n    getNote() {\n        return this.froca.notes[this.ownerId];\n    }\n\n    /** @return {FBlob} */\n    async getBlob() {\n        return await this.froca.getBlob('attachments', this.attachmentId);\n    }\n}\n\nexport default FAttachment;\n","import promotedAttributeDefinitionParser from '../services/promoted_attribute_definition_parser.js';\n\n/**\n * There are currently only two types of attributes, labels or relations.\n * @typedef {\"label\" | \"relation\"} AttributeType\n */\n\n/**\n * Attribute is an abstract concept which has two real uses - label (key - value pair)\n * and relation (representing named relationship between source and target note)\n */\nclass FAttribute {\n    constructor(froca, row) {\n        /** @type {Froca} */\n        this.froca = froca;\n\n        this.update(row);\n    }\n\n    update(row) {\n        /** @type {string} */\n        this.attributeId = row.attributeId;\n        /** @type {string} */\n        this.noteId = row.noteId;\n        /** @type {AttributeType} */\n        this.type = row.type;\n        /** @type {string} */\n        this.name = row.name;\n        /** @type {string} */\n        this.value = row.value;\n        /** @type {int} */\n        this.position = row.position;\n        /** @type {boolean} */\n        this.isInheritable = !!row.isInheritable;\n    }\n\n    /** @returns {FNote} */\n    getNote() {\n        return this.froca.notes[this.noteId];\n    }\n\n    /** @returns {Promise<FNote>} */\n    async getTargetNote() {\n        const targetNoteId = this.targetNoteId;\n\n        return await this.froca.getNote(targetNoteId, true);\n    }\n\n    get targetNoteId() { // alias\n        if (this.type !== 'relation') {\n            throw new Error(`Attribute ${this.attributeId} is not a relation`);\n        }\n\n        return this.value;\n    }\n\n    get isAutoLink() {\n        return this.type === 'relation' && ['internalLink', 'imageLink', 'relationMapLink', 'includeNoteLink'].includes(this.name);\n    }\n\n    get toString() {\n        return `FAttribute(attributeId=${this.attributeId}, type=${this.type}, name=${this.name}, value=${this.value})`;\n    }\n\n    isDefinition() {\n        return this.type === 'label' && (this.name.startsWith('label:') || this.name.startsWith('relation:'));\n    }\n\n    getDefinition() {\n        return promotedAttributeDefinitionParser.parse(this.value);\n    }\n\n    isDefinitionFor(attr) {\n        return this.type === 'label' && this.name === `${attr.type}:${attr.name}`;\n    }\n\n    get dto() {\n        const dto = Object.assign({}, this);\n        delete dto.froca;\n\n        return dto;\n    }\n}\n\nexport default FAttribute;\n","/**\n * Branch represents a relationship between a child note and its parent note. Trilium allows a note to have multiple\n * parents.\n */\nclass FBranch {\n    constructor(froca, row) {\n        /** @type {Froca} */\n        this.froca = froca;\n\n        this.update(row);\n    }\n\n    update(row) {\n        /**\n         * primary key\n         * @type {string}\n         */\n        this.branchId = row.branchId;\n        /** @type {string} */\n        this.noteId = row.noteId;\n        /** @type {string} */\n        this.parentNoteId = row.parentNoteId;\n        /** @type {int} */\n        this.notePosition = row.notePosition;\n        /** @type {string} */\n        this.prefix = row.prefix;\n        /** @type {boolean} */\n        this.isExpanded = !!row.isExpanded;\n        /** @type {boolean} */\n        this.fromSearchNote = !!row.fromSearchNote;\n    }\n\n    /** @returns {FNote} */\n    async getNote() {\n        return this.froca.getNote(this.noteId);\n    }\n\n    /** @returns {FNote} */\n    getNoteFromCache() {\n        return this.froca.getNoteFromCache(this.noteId);\n    }\n\n    /** @returns {FNote} */\n    async getParentNote() {\n        return this.froca.getNote(this.parentNoteId);\n    }\n\n    /** @returns {boolean} true if it's top level, meaning its parent is the root note */\n    isTopLevel() {\n        return this.parentNoteId === 'root';\n    }\n\n    get toString() {\n        return `FBranch(branchId=${this.branchId})`;\n    }\n\n    get pojo() {\n        const pojo = {...this};\n        delete pojo.froca;\n        return pojo;\n    }\n}\n\nexport default FBranch;\n","const registeredClasses = new Set();\n\nfunction createClassForColor(color) {\n    if (!color?.trim()) {\n        return \"\";\n    }\n\n    const normalizedColorName = color.replace(/[^a-z0-9]/gi, \"\");\n\n    if (!normalizedColorName.trim()) {\n        return \"\";\n    }\n\n    const className = `color-${normalizedColorName}`;\n\n    if (!registeredClasses.has(className)) {\n        // make the active fancytree selector more specific than the normal color setting\n        $(\"head\").append(`<style>.${className}, span.fancytree-active.${className} { color: ${color} !important; }</style>`);\n\n        registeredClasses.add(className);\n    }\n\n    return className;\n}\n\nexport default {\n    createClassForColor\n};\n","import server from '../services/server.js';\nimport noteAttributeCache from \"../services/note_attribute_cache.js\";\nimport ws from \"../services/ws.js\";\nimport froca from \"../services/froca.js\";\nimport protectedSessionHolder from \"../services/protected_session_holder.js\";\nimport cssClassManager from \"../services/css_class_manager.js\";\n\nconst LABEL = 'label';\nconst RELATION = 'relation';\n\nconst NOTE_TYPE_ICONS = {\n    \"file\": \"bx bx-file\",\n    \"image\": \"bx bx-image\",\n    \"code\": \"bx bx-code\",\n    \"render\": \"bx bx-extension\",\n    \"search\": \"bx bx-file-find\",\n    \"relationMap\": \"bx bx-map-alt\",\n    \"book\": \"bx bx-book\",\n    \"noteMap\": \"bx bx-map-alt\",\n    \"mermaid\": \"bx bx-selection\",\n    \"canvas\": \"bx bx-pen\",\n    \"webView\": \"bx bx-globe-alt\",\n    \"launcher\": \"bx bx-link\",\n    \"doc\": \"bx bxs-file-doc\",\n    \"contentWidget\": \"bx bxs-widget\"\n};\n\n/**\n * There are many different Note types, some of which are entirely opaque to the\n * end user. Those types should be used only for checking against, they are\n * not for direct use.\n * @typedef {\"file\" | \"image\" | \"search\" | \"noteMap\" | \"launcher\" | \"doc\" | \"contentWidget\" | \"text\" | \"relationMap\" | \"render\" | \"canvas\" | \"mermaid\" | \"book\" | \"webView\" | \"code\"} NoteType\n */\n\n/**\n * @typedef {Object} NotePathRecord\n * @property {boolean} isArchived\n * @property {boolean} isInHoistedSubTree\n * @property {boolean} isSearch\n * @property {Array<string>} notePath\n * @property {boolean} isHidden\n */\n\n/**\n * Note is the main node and concept in Trilium.\n */\nclass FNote {\n    /**\n     * @param {Froca} froca\n     * @param {Object.<string, Object>} row\n     */\n    constructor(froca, row) {\n        /** @type {Froca} */\n        this.froca = froca;\n\n        /** @type {string[]} */\n        this.attributes = [];\n\n        /** @type {string[]} */\n        this.targetRelations = [];\n\n        /** @type {string[]} */\n        this.parents = [];\n        /** @type {string[]} */\n        this.children = [];\n\n        /** @type {Object.<string, string>} */\n        this.parentToBranch = {};\n\n        /** @type {Object.<string, string>} */\n        this.childToBranch = {};\n\n        /** @type {FAttachment[]|null} */\n        this.attachments = null; // lazy loaded\n\n        this.update(row);\n    }\n\n    update(row) {\n        /** @type {string} */\n        this.noteId = row.noteId;\n        /** @type {string} */\n        this.title = row.title;\n        /** @type {boolean} */\n        this.isProtected = !!row.isProtected;\n        /**\n         * See {@see NoteType} for info on values.\n         * @type {NoteType}\n         */\n        this.type = row.type;\n        /**\n         * content-type, e.g. \"application/json\"\n         * @type {string}\n         */\n        this.mime = row.mime;\n\n        // the main use case to keep this is to detect content change which should trigger refresh\n        this.blobId = row.blobId;\n    }\n\n    addParent(parentNoteId, branchId, sort = true) {\n        if (parentNoteId === 'none') {\n            return;\n        }\n\n        if (!this.parents.includes(parentNoteId)) {\n            this.parents.push(parentNoteId);\n        }\n\n        this.parentToBranch[parentNoteId] = branchId;\n\n        if (sort) {\n            this.sortParents();\n        }\n    }\n\n    addChild(childNoteId, branchId, sort = true) {\n        if (!(childNoteId in this.childToBranch)) {\n            this.children.push(childNoteId);\n        }\n\n        this.childToBranch[childNoteId] = branchId;\n\n        if (sort) {\n            this.sortChildren();\n        }\n    }\n\n    sortChildren() {\n        const branchIdPos = {};\n\n        for (const branchId of Object.values(this.childToBranch)) {\n            branchIdPos[branchId] = this.froca.getBranch(branchId).notePosition;\n        }\n\n        this.children.sort((a, b) => branchIdPos[this.childToBranch[a]] - branchIdPos[this.childToBranch[b]]);\n    }\n\n    /** @returns {boolean} */\n    isJson() {\n        return this.mime === \"application/json\";\n    }\n\n    async getContent() {\n        const blob = await this.getBlob();\n\n        return blob?.content;\n    }\n\n    async getJsonContent() {\n        const content = await this.getContent();\n\n        try {\n            return JSON.parse(content);\n        }\n        catch (e) {\n            console.log(`Cannot parse content of note '${this.noteId}': `, e.message);\n\n            return null;\n        }\n    }\n\n    /**\n     * @returns {string[]}\n     */\n    getParentBranchIds() {\n        return Object.values(this.parentToBranch);\n    }\n\n    /**\n     * @returns {string[]}\n     * @deprecated use getParentBranchIds() instead\n     */\n    getBranchIds() {\n        return this.getParentBranchIds();\n    }\n\n    /**\n     * @returns {FBranch[]}\n     */\n    getParentBranches() {\n        const branchIds = Object.values(this.parentToBranch);\n\n        return this.froca.getBranches(branchIds);\n    }\n\n    /**\n     * @returns {FBranch[]}\n     * @deprecated use getParentBranches() instead\n     */\n    getBranches() {\n        return this.getParentBranches();\n    }\n\n    /** @returns {boolean} */\n    hasChildren() {\n        return this.children.length > 0;\n    }\n\n    /** @returns {FBranch[]} */\n    getChildBranches() {\n        // don't use Object.values() to guarantee order\n        const branchIds = this.children.map(childNoteId => this.childToBranch[childNoteId]);\n\n        return this.froca.getBranches(branchIds);\n    }\n\n    /** @returns {string[]} */\n    getParentNoteIds() {\n        return this.parents;\n    }\n\n    /** @returns {FNote[]} */\n    getParentNotes() {\n        return this.froca.getNotesFromCache(this.parents);\n    }\n\n    // will sort the parents so that non-search & non-archived are first and archived at the end\n    // this is done so that non-search & non-archived paths are always explored as first when looking for a note path\n    sortParents() {\n        this.parents.sort((aNoteId, bNoteId) => {\n            const aBranchId = this.parentToBranch[aNoteId];\n\n            if (aBranchId && aBranchId.startsWith('virt-')) {\n                return 1;\n            }\n\n            const aNote = this.froca.getNoteFromCache(aNoteId);\n\n            if (aNote.isArchived || aNote.isHiddenCompletely()) {\n                return 1;\n            }\n\n            return aNoteId < bNoteId ? -1 : 1;\n        });\n    }\n\n    get isArchived() {\n        return this.hasAttribute('label', 'archived');\n    }\n\n    /** @returns {string[]} */\n    getChildNoteIds() {\n        return this.children;\n    }\n\n    /** @returns {Promise<FNote[]>} */\n    async getChildNotes() {\n        return await this.froca.getNotes(this.children);\n    }\n\n    /** @returns {Promise<FAttachment[]>} */\n    async getAttachments() {\n        if (!this.attachments) {\n            this.attachments = await this.froca.getAttachmentsForNote(this.noteId);\n        }\n\n        return this.attachments;\n    }\n\n    /** @returns {Promise<FAttachment[]>} */\n    async getAttachmentsByRole(role) {\n        return (await this.getAttachments())\n            .filter(attachment => attachment.role === role);\n    }\n\n    /** @returns {Promise<FAttachment>} */\n    async getAttachmentById(attachmentId) {\n        const attachments = await this.getAttachments();\n\n        return attachments.find(att => att.attachmentId === attachmentId);\n    }\n\n    isEligibleForConversionToAttachment() {\n        if (this.type !== 'image' || !this.isContentAvailable() || this.hasChildren() || this.getParentBranches().length !== 1) {\n            return false;\n        }\n\n        const targetRelations = this.getTargetRelations().filter(relation => relation.name === 'imageLink');\n\n        if (targetRelations.length > 1) {\n            return false;\n        }\n\n        const parentNote = this.getParentNotes()[0]; // at this point note can have only one parent\n        const referencingNote = targetRelations[0]?.getNote();\n\n        if (referencingNote && referencingNote !== parentNote) {\n            return false;\n        } else if (parentNote.type !== 'text' || !parentNote.isContentAvailable()) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {string} [type] - (optional) attribute type to filter\n     * @param {string} [name] - (optional) attribute name to filter\n     * @returns {FAttribute[]} all note's attributes, including inherited ones\n     */\n    getOwnedAttributes(type, name) {\n        const attrs = this.attributes\n            .map(attributeId => this.froca.attributes[attributeId])\n            .filter(Boolean); // filter out nulls;\n\n        return this.__filterAttrs(attrs, type, name);\n    }\n\n    /**\n     * @param {string} [type] - (optional) attribute type to filter\n     * @param {string} [name] - (optional) attribute name to filter\n     * @returns {FAttribute[]} all note's attributes, including inherited ones\n     */\n    getAttributes(type, name) {\n        return this.__filterAttrs(this.__getCachedAttributes([]), type, name);\n    }\n\n    /**\n     * @param {string[]} path\n     * @return {FAttribute[]}\n     * @private\n     */\n    __getCachedAttributes(path) {\n        // notes/clones cannot form tree cycles, it is possible to create attribute inheritance cycle via templates\n        // when template instance is a parent of template itself\n        if (path.includes(this.noteId)) {\n            return [];\n        }\n\n        if (!(this.noteId in noteAttributeCache.attributes)) {\n            const newPath = [...path, this.noteId];\n            const attrArrs = [ this.getOwnedAttributes() ];\n\n            // inheritable attrs on root are typically not intended to be applied to hidden subtree #3537\n            if (this.noteId !== 'root' && this.noteId !== '_hidden') {\n                for (const parentNote of this.getParentNotes()) {\n                    // these virtual parent-child relationships are also loaded into froca\n                    if (parentNote.type !== 'search') {\n                        attrArrs.push(parentNote.__getInheritableAttributes(newPath));\n                    }\n                }\n            }\n\n            for (const templateAttr of attrArrs.flat().filter(attr => attr.type === 'relation' && ['template', 'inherit'].includes(attr.name))) {\n                const templateNote = this.froca.notes[templateAttr.value];\n\n                if (templateNote && templateNote.noteId !== this.noteId) {\n                    attrArrs.push(\n                        templateNote.__getCachedAttributes(newPath)\n                            // template attr is used as a marker for templates, but it's not meant to be inherited\n                            .filter(attr => !(attr.type === 'label' && (attr.name === 'template' || attr.name === 'workspacetemplate')))\n                    );\n                }\n            }\n\n            noteAttributeCache.attributes[this.noteId] = [];\n            const addedAttributeIds = new Set();\n\n            for (const attr of attrArrs.flat()) {\n                if (!addedAttributeIds.has(attr.attributeId)) {\n                    addedAttributeIds.add(attr.attributeId);\n\n                    noteAttributeCache.attributes[this.noteId].push(attr);\n                }\n            }\n        }\n\n        return noteAttributeCache.attributes[this.noteId];\n    }\n\n    isRoot() {\n        return this.noteId === 'root';\n    }\n\n    /**\n     * Gives all possible note paths leading to this note. Paths containing search note are ignored (could form cycles)\n     *\n     * @returns {string[][]} - array of notePaths (each represented by array of noteIds constituting the particular note path)\n     */\n    getAllNotePaths() {\n        if (this.noteId === 'root') {\n            return [['root']];\n        }\n\n        const parentNotes = this.getParentNotes().filter(note => note.type !== 'search');\n\n        const notePaths = parentNotes.length === 1\n            ? parentNotes[0].getAllNotePaths() // optimization for the most common case\n            : parentNotes.flatMap(parentNote => parentNote.getAllNotePaths());\n\n        for (const notePath of notePaths) {\n            notePath.push(this.noteId);\n        }\n\n        return notePaths;\n    }\n\n    /**\n     * @param {string} [hoistedNoteId='root']\n     * @return {Array<NotePathRecord>}\n     */\n    getSortedNotePathRecords(hoistedNoteId = 'root') {\n        const isHoistedRoot = hoistedNoteId === 'root';\n\n        const notePaths = this.getAllNotePaths().map(path => ({\n            notePath: path,\n            isInHoistedSubTree: isHoistedRoot || path.includes(hoistedNoteId),\n            isArchived: path.some(noteId => froca.notes[noteId].isArchived),\n            isSearch: path.find(noteId => froca.notes[noteId].type === 'search'),\n            isHidden: path.includes('_hidden')\n        }));\n\n        notePaths.sort((a, b) => {\n            if (a.isInHoistedSubTree !== b.isInHoistedSubTree) {\n                return a.isInHoistedSubTree ? -1 : 1;\n            } else if (a.isArchived !== b.isArchived) {\n                return a.isArchived ? 1 : -1;\n            } else if (a.isHidden !== b.isHidden) {\n                return a.isHidden ? 1 : -1;\n            } else if (a.isSearch !== b.isSearch) {\n                return a.isSearch ? 1 : -1;\n            } else {\n                return a.notePath.length - b.notePath.length;\n            }\n        });\n\n        return notePaths;\n    }\n\n    /**\n     * Returns the note path considered to be the \"best\"\n     *\n     * @param {string} [hoistedNoteId='root']\n     * @return {string[]} array of noteIds constituting the particular note path\n     */\n    getBestNotePath(hoistedNoteId = 'root') {\n        return this.getSortedNotePathRecords(hoistedNoteId)[0]?.notePath;\n    }\n\n    /**\n     * Returns the note path considered to be the \"best\"\n     *\n     * @param {string} [hoistedNoteId='root']\n     * @return {string} serialized note path (e.g. 'root/a1h315/js725h')\n     */\n    getBestNotePathString(hoistedNoteId = 'root') {\n        const notePath = this.getBestNotePath(hoistedNoteId);\n\n        return notePath?.join(\"/\");\n    }\n\n    /**\n     * @return boolean - true if there's no non-hidden path, note is not cloned to the visible tree\n     */\n    isHiddenCompletely() {\n        if (this.noteId === '_hidden') {\n            return true;\n        } else if (this.noteId === 'root') {\n            return false;\n        }\n\n        for (const parentNote of this.getParentNotes()) {\n            if (parentNote.noteId === 'root') {\n                return false;\n            } else if (parentNote.noteId === '_hidden' || parentNote.type === 'search') {\n                continue;\n            }\n\n            if (!parentNote.isHiddenCompletely()) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {FAttribute[]} attributes\n     * @param {AttributeType} type\n     * @param {string} name\n     * @return {FAttribute[]}\n     * @private\n     */\n    __filterAttrs(attributes, type, name) {\n        this.__validateTypeName(type, name);\n\n        if (!type && !name) {\n            return attributes;\n        } else if (type && name) {\n            return attributes.filter(attr => attr.name === name && attr.type === type);\n        } else if (type) {\n            return attributes.filter(attr => attr.type === type);\n        } else if (name) {\n            return attributes.filter(attr => attr.name === name);\n        }\n    }\n\n    __getInheritableAttributes(path) {\n        const attrs = this.__getCachedAttributes(path);\n\n        return attrs.filter(attr => attr.isInheritable);\n    }\n\n    __validateTypeName(type, name) {\n        if (type && type !== 'label' && type !== 'relation') {\n            throw new Error(`Unrecognized attribute type '${type}'. Only 'label' and 'relation' are possible values.`);\n        }\n\n        if (name) {\n            const firstLetter = name.charAt(0);\n            if (firstLetter === '#' || firstLetter === '~') {\n                throw new Error(`Detect '#' or '~' in the attribute's name. In the API, attribute names should be set without these characters.`);\n            }\n        }\n    }\n\n    /**\n     * @param {string} [name] - label name to filter\n     * @returns {FAttribute[]} all note's labels (attributes with type label), including inherited ones\n     */\n    getOwnedLabels(name) {\n        return this.getOwnedAttributes(LABEL, name);\n    }\n\n    /**\n     * @param {string} [name] - label name to filter\n     * @returns {FAttribute[]} all note's labels (attributes with type label), including inherited ones\n     */\n    getLabels(name) {\n        return this.getAttributes(LABEL, name);\n    }\n\n    getIcon() {\n        const iconClassLabels = this.getLabels('iconClass');\n        const workspaceIconClass = this.getWorkspaceIconClass();\n\n        if (iconClassLabels.length > 0) {\n            return iconClassLabels[0].value;\n        }\n        else if (workspaceIconClass) {\n            return workspaceIconClass;\n        }\n        else if (this.noteId === 'root') {\n            return \"bx bx-chevrons-right\";\n        }\n        if (this.noteId === '_share') {\n            return \"bx bx-share-alt\";\n        }\n        else if (this.type === 'text') {\n            if (this.isFolder()) {\n                return \"bx bx-folder\";\n            }\n            else {\n                return \"bx bx-note\";\n            }\n        }\n        else if (this.type === 'code' && this.mime.startsWith('text/x-sql')) {\n            return \"bx bx-data\";\n        }\n        else {\n            return NOTE_TYPE_ICONS[this.type];\n        }\n    }\n\n    getColorClass() {\n        const color = this.getLabelValue(\"color\");\n        return cssClassManager.createClassForColor(color);\n    }\n\n    isFolder() {\n        return this.type === 'search'\n            || this.getFilteredChildBranches().length > 0;\n    }\n\n    getFilteredChildBranches() {\n        let childBranches = this.getChildBranches();\n\n        if (!childBranches) {\n            ws.logError(`No children for '${this.noteId}'. This shouldn't happen.`);\n            return;\n        }\n\n        // we're not checking hideArchivedNotes since that would mean we need to lazy load the child notes\n        // which would seriously slow down everything.\n        // we check this flag only once user chooses to expand the parent. This has the negative consequence that\n        // note may appear as a folder but not contain any children when all of them are archived\n\n        return childBranches;\n    }\n\n    /**\n     * @param {string} [name] - relation name to filter\n     * @returns {FAttribute[]} all note's relations (attributes with type relation), including inherited ones\n     */\n    getOwnedRelations(name) {\n        return this.getOwnedAttributes(RELATION, name);\n    }\n\n    /**\n     * @param {string} [name] - relation name to filter\n     * @returns {FAttribute[]} all note's relations (attributes with type relation), including inherited ones\n     */\n    getRelations(name) {\n        return this.getAttributes(RELATION, name);\n    }\n\n    /**\n     * @param {AttributeType} type - attribute type (label, relation, etc.)\n     * @param {string} name - attribute name\n     * @returns {boolean} true if note has an attribute with given type and name (including inherited)\n     */\n    hasAttribute(type, name) {\n        const attributes = this.getAttributes();\n\n        return attributes.some(attr => attr.name === name && attr.type === type);\n    }\n\n    /**\n     * @param {AttributeType} type - attribute type (label, relation, etc.)\n     * @param {string} name - attribute name\n     * @returns {boolean} true if note has an attribute with given type and name (including inherited)\n     */\n    hasOwnedAttribute(type, name) {\n        return !!this.getOwnedAttribute(type, name);\n    }\n\n    /**\n     * @param {AttributeType} type - attribute type (label, relation, etc.)\n     * @param {string} name - attribute name\n     * @returns {FAttribute} attribute of the given type and name. If there are more such attributes, first is returned. Returns null if there's no such attribute belonging to this note.\n     */\n    getOwnedAttribute(type, name) {\n        const attributes = this.getOwnedAttributes();\n\n        return attributes.find(attr => attr.name === name && attr.type === type);\n    }\n\n    /**\n     * @param {AttributeType} type - attribute type (label, relation, etc.)\n     * @param {string} name - attribute name\n     * @returns {FAttribute} attribute of the given type and name. If there are more such attributes, first is returned. Returns null if there's no such attribute belonging to this note.\n     */\n    getAttribute(type, name) {\n        const attributes = this.getAttributes();\n\n        return attributes.find(attr => attr.name === name && attr.type === type);\n    }\n\n    /**\n     * @param {AttributeType} type - attribute type (label, relation, etc.)\n     * @param {string} name - attribute name\n     * @returns {string} attribute value of the given type and name or null if no such attribute exists.\n     */\n    getOwnedAttributeValue(type, name) {\n        const attr = this.getOwnedAttribute(type, name);\n\n        return attr ? attr.value : null;\n    }\n\n    /**\n     * @param {AttributeType} type - attribute type (label, relation, etc.)\n     * @param {string} name - attribute name\n     * @returns {string} attribute value of the given type and name or null if no such attribute exists.\n     */\n    getAttributeValue(type, name) {\n        const attr = this.getAttribute(type, name);\n\n        return attr ? attr.value : null;\n    }\n\n    /**\n     * @param {string} name - label name\n     * @returns {boolean} true if label exists (excluding inherited)\n     */\n    hasOwnedLabel(name) { return this.hasOwnedAttribute(LABEL, name); }\n\n    /**\n     * @param {string} name - label name\n     * @returns {boolean} true if label exists (including inherited)\n     */\n    hasLabel(name) { return this.hasAttribute(LABEL, name); }\n\n    /**\n     * @param {string} name - label name\n     * @returns {boolean} true if label exists (including inherited) and does not have \"false\" value.\n     */\n    isLabelTruthy(name) {\n        const label = this.getLabel(name);\n\n        if (!label) {\n            return false;\n        }\n\n        return label && label.value !== 'false';\n    }\n\n    /**\n     * @param {string} name - relation name\n     * @returns {boolean} true if relation exists (excluding inherited)\n     */\n    hasOwnedRelation(name) { return this.hasOwnedAttribute(RELATION, name); }\n\n    /**\n     * @param {string} name - relation name\n     * @returns {boolean} true if relation exists (including inherited)\n     */\n    hasRelation(name) { return this.hasAttribute(RELATION, name); }\n\n    /**\n     * @param {string} name - label name\n     * @returns {FAttribute} label if it exists, null otherwise\n     */\n    getOwnedLabel(name) { return this.getOwnedAttribute(LABEL, name); }\n\n    /**\n     * @param {string} name - label name\n     * @returns {FAttribute} label if it exists, null otherwise\n     */\n    getLabel(name) { return this.getAttribute(LABEL, name); }\n\n    /**\n     * @param {string} name - relation name\n     * @returns {FAttribute} relation if it exists, null otherwise\n     */\n    getOwnedRelation(name) { return this.getOwnedAttribute(RELATION, name); }\n\n    /**\n     * @param {string} name - relation name\n     * @returns {FAttribute} relation if it exists, null otherwise\n     */\n    getRelation(name) { return this.getAttribute(RELATION, name); }\n\n    /**\n     * @param {string} name - label name\n     * @returns {string} label value if label exists, null otherwise\n     */\n    getOwnedLabelValue(name) { return this.getOwnedAttributeValue(LABEL, name); }\n\n    /**\n     * @param {string} name - label name\n     * @returns {string} label value if label exists, null otherwise\n     */\n    getLabelValue(name) { return this.getAttributeValue(LABEL, name); }\n\n    /**\n     * @param {string} name - relation name\n     * @returns {string} relation value if relation exists, null otherwise\n     */\n    getOwnedRelationValue(name) { return this.getOwnedAttributeValue(RELATION, name); }\n\n    /**\n     * @param {string} name - relation name\n     * @returns {string} relation value if relation exists, null otherwise\n     */\n    getRelationValue(name) { return this.getAttributeValue(RELATION, name); }\n\n    /**\n     * @param {string} name\n     * @returns {Promise<FNote>|null} target note of the relation or null (if target is empty or note was not found)\n     */\n    async getRelationTarget(name) {\n        const targets = await this.getRelationTargets(name);\n\n        return targets.length > 0 ? targets[0] : null;\n    }\n\n    /**\n     * @param {string} [name] - relation name to filter\n     * @returns {Promise<FNote[]>}\n     */\n    async getRelationTargets(name) {\n        const relations = this.getRelations(name);\n        const targets = [];\n\n        for (const relation of relations) {\n            targets.push(await this.froca.getNote(relation.value));\n        }\n\n        return targets;\n    }\n\n    /**\n     * @returns {FNote[]}\n     */\n    getNotesToInheritAttributesFrom() {\n        const relations = [\n            ...this.getRelations('template'),\n            ...this.getRelations('inherit')\n        ];\n\n        return relations.map(rel => this.froca.notes[rel.value]);\n    }\n\n    getPromotedDefinitionAttributes() {\n        if (this.isLabelTruthy('hidePromotedAttributes')) {\n            return [];\n        }\n\n        const promotedAttrs = this.getAttributes()\n            .filter(attr => attr.isDefinition())\n            .filter(attr => {\n                const def = attr.getDefinition();\n\n                return def && def.isPromoted;\n            });\n\n        // attrs are not resorted if position changes after the initial load\n        promotedAttrs.sort((a, b) => {\n            if (a.noteId === b.noteId) {\n                return a.position < b.position ? -1 : 1;\n            } else {\n                // inherited promoted attributes should stay grouped: https://github.com/zadam/trilium/issues/3761\n                return a.noteId < b.noteId ? -1 : 1;\n            }\n        });\n\n        return promotedAttrs;\n    }\n\n    hasAncestor(ancestorNoteId, followTemplates = false, visitedNoteIds = null) {\n        if (this.noteId === ancestorNoteId) {\n            return true;\n        }\n\n        if (!visitedNoteIds) {\n            visitedNoteIds = new Set();\n        } else if (visitedNoteIds.has(this.noteId)) {\n            // to avoid infinite cycle when template is descendent of the instance\n            return false;\n        }\n\n        visitedNoteIds.add(this.noteId);\n\n        if (followTemplates) {\n            for (const templateNote of this.getNotesToInheritAttributesFrom()) {\n                if (templateNote.hasAncestor(ancestorNoteId, followTemplates, visitedNoteIds)) {\n                    return true;\n                }\n            }\n        }\n\n        for (const parentNote of this.getParentNotes()) {\n            if (parentNote.hasAncestor(ancestorNoteId, followTemplates, visitedNoteIds)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    isInHiddenSubtree() {\n        return this.noteId === '_hidden' || this.hasAncestor('_hidden');\n    }\n\n    /**\n     * @deprecated NOOP\n     */\n    invalidateAttributeCache() {}\n\n    /**\n     * Get relations which target this note\n     *\n     * @returns {FAttribute[]}\n     */\n    getTargetRelations() {\n        return this.targetRelations\n            .map(attributeId => this.froca.attributes[attributeId]);\n    }\n\n    /**\n     * Get relations which target this note\n     *\n     * @returns {Promise<FNote[]>}\n     */\n    async getTargetRelationSourceNotes() {\n        const targetRelations = this.getTargetRelations();\n\n        return await this.froca.getNotes(targetRelations.map(tr => tr.noteId));\n    }\n\n    /**\n     * @deprecated use getBlob() instead\n     * @return {Promise<FBlob>}\n     */\n    async getNoteComplement() {\n        return this.getBlob();\n    }\n\n    /** @return {Promise<FBlob>} */\n    async getBlob() {\n        return await this.froca.getBlob('notes', this.noteId);\n    }\n\n    toString() {\n        return `Note(noteId=${this.noteId}, title=${this.title})`;\n    }\n\n    get dto() {\n        const dto = Object.assign({}, this);\n        delete dto.froca;\n\n        return dto;\n    }\n\n    getCssClass() {\n        const labels = this.getLabels('cssClass');\n        return labels.map(l => l.value).join(' ');\n    }\n\n    getWorkspaceIconClass() {\n        const labels = this.getLabels('workspaceIconClass');\n        return labels.length > 0 ? labels[0].value : \"\";\n    }\n\n    getWorkspaceTabBackgroundColor() {\n        const labels = this.getLabels('workspaceTabBackgroundColor');\n        return labels.length > 0 ? labels[0].value : \"\";\n    }\n\n    /** @returns {boolean} true if this note is JavaScript (code or file) */\n    isJavaScript() {\n        return (this.type === \"code\" || this.type === \"file\" || this.type === 'launcher')\n            && (this.mime.startsWith(\"application/javascript\")\n                || this.mime === \"application/x-javascript\"\n                || this.mime === \"text/javascript\");\n    }\n\n    /** @returns {boolean} true if this note is HTML */\n    isHtml() {\n        return (this.type === \"code\" || this.type === \"file\" || this.type === \"render\") && this.mime === \"text/html\";\n    }\n\n    /** @returns {string|null} JS script environment - either \"frontend\" or \"backend\" */\n    getScriptEnv() {\n        if (this.isHtml() || (this.isJavaScript() && this.mime.endsWith('env=frontend'))) {\n            return \"frontend\";\n        }\n\n        if (this.type === 'render') {\n            return \"frontend\";\n        }\n\n        if (this.isJavaScript() && this.mime.endsWith('env=backend')) {\n            return \"backend\";\n        }\n\n        return null;\n    }\n\n    async executeScript() {\n        if (!this.isJavaScript()) {\n            throw new Error(`Note ${this.noteId} is of type ${this.type} and mime ${this.mime} and thus cannot be executed`);\n        }\n\n        const env = this.getScriptEnv();\n\n        if (env === \"frontend\") {\n            const bundleService = (await import(\"../services/bundle.js\")).default;\n            return await bundleService.getAndExecuteBundle(this.noteId);\n        }\n        else if (env === \"backend\") {\n            const resp = await server.post(`script/run/${this.noteId}`);\n        }\n        else {\n            throw new Error(`Unrecognized env type ${env} for note ${this.noteId}`);\n        }\n    }\n\n    isShared() {\n        for (const parentNoteId of this.parents) {\n            if (parentNoteId === 'root' || parentNoteId === 'none') {\n                continue;\n            }\n\n            const parentNote = froca.notes[parentNoteId];\n\n            if (!parentNote || parentNote.type === 'search') {\n                continue;\n            }\n\n            if (parentNote.noteId === '_share' || parentNote.isShared()) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    isContentAvailable() {\n        return !this.isProtected || protectedSessionHolder.isProtectedSessionAvailable()\n    }\n\n    isLaunchBarConfig() {\n        return this.type === 'launcher' || ['_lbRoot', '_lbAvailableLaunchers', '_lbVisibleLaunchers'].includes(this.noteId);\n    }\n\n    isOptions() {\n        return this.noteId.startsWith(\"_options\");\n    }\n\n    /**\n     * Provides note's date metadata.\n     *\n     * @returns {Promise<{dateCreated: string, utcDateCreated: string, dateModified: string, utcDateModified: string}>}\n     */\n    async getMetadata() {\n        return await server.get(`notes/${this.noteId}/metadata`);\n    }\n}\n\nexport default FNote;\n","import keyboardActionService from '../services/keyboard_actions.js';\n\nclass ContextMenu {\n    constructor() {\n        this.$widget = $(\"#context-menu-container\");\n        this.dateContextMenuOpenedMs = 0;\n\n        $(document).on('click', () => this.hide());\n    }\n\n    async show(options) {\n        this.options = options;\n\n        this.$widget.empty();\n\n        this.addItems(this.$widget, options.items);\n\n        keyboardActionService.updateDisplayedShortcuts(this.$widget);\n\n        this.positionMenu();\n\n        this.dateContextMenuOpenedMs = Date.now();\n    }\n\n    positionMenu() {\n        // the code below tries to detect when dropdown would overflow from page\n        // in such case we'll position it above click coordinates, so it will fit into the client\n\n        const CONTEXT_MENU_PADDING = 5; // How many pixels to pad the context menu from edge of screen\n        const CONTEXT_MENU_OFFSET = 0; // How many pixels to offset the context menu by relative to cursor, see #3157\n\n        const clientHeight = document.documentElement.clientHeight;\n        const clientWidth = document.documentElement.clientWidth;\n        const contextMenuHeight = this.$widget.outerHeight();\n        const contextMenuWidth = this.$widget.outerWidth();\n        let top, left;\n\n        if (this.options.y + contextMenuHeight - CONTEXT_MENU_OFFSET > clientHeight - CONTEXT_MENU_PADDING) {\n            // Overflow: bottom\n            top = clientHeight - contextMenuHeight - CONTEXT_MENU_PADDING;\n        } else if (this.options.y - CONTEXT_MENU_OFFSET < CONTEXT_MENU_PADDING) {\n            // Overflow: top\n            top = CONTEXT_MENU_PADDING;\n        } else {\n            top = this.options.y - CONTEXT_MENU_OFFSET;\n        }\n\n        if (this.options.orientation === 'left') {\n            if (this.options.x + CONTEXT_MENU_OFFSET > clientWidth - CONTEXT_MENU_PADDING) {\n                // Overflow: right\n                left = clientWidth - contextMenuWidth - CONTEXT_MENU_OFFSET;\n            } else if (this.options.x - contextMenuWidth + CONTEXT_MENU_OFFSET < CONTEXT_MENU_PADDING) {\n                // Overflow: left\n                left = CONTEXT_MENU_PADDING;\n            } else {\n                left = this.options.x - contextMenuWidth + CONTEXT_MENU_OFFSET;\n            }\n        } else {\n            if (this.options.x + contextMenuWidth - CONTEXT_MENU_OFFSET > clientWidth - CONTEXT_MENU_PADDING) {\n                // Overflow: right\n                left = clientWidth - contextMenuWidth - CONTEXT_MENU_PADDING;\n            } else if (this.options.x - CONTEXT_MENU_OFFSET < CONTEXT_MENU_PADDING) {\n                // Overflow: left\n                left = CONTEXT_MENU_PADDING;\n            } else {\n                left = this.options.x - CONTEXT_MENU_OFFSET;\n            }\n        }\n\n        this.$widget.css({\n            display: \"block\",\n            top: top,\n            left: left\n        }).addClass(\"show\");\n    }\n\n    addItems($parent, items) {\n        for (const item of items) {\n            if (!item) {\n                continue;\n            }\n\n            if (item.title === '----') {\n                $parent.append($(\"<div>\").addClass(\"dropdown-divider\"));\n            } else {\n                const $icon = $(\"<span>\");\n\n                if (item.uiIcon) {\n                    $icon.addClass(item.uiIcon);\n                } else {\n                    $icon.append(\"&nbsp;\");\n                }\n\n                const $link = $(\"<span>\")\n                    .append($icon)\n                    .append(\" &nbsp; \") // some space between icon and text\n                    .append(item.title);\n\n                const $item = $(\"<li>\")\n                    .addClass(\"dropdown-item\")\n                    .append($link)\n                    .on('contextmenu', e => false)\n                    // important to use mousedown instead of click since the former does not change focus\n                    // (especially important for focused text for spell check)\n                    .on('mousedown', e => {\n                        e.stopPropagation();\n\n                        if (e.which !== 1) { // only left click triggers menu items\n                            return false;\n                        }\n\n                        this.hide();\n\n                        if (item.handler) {\n                            item.handler(item, e);\n                        }\n\n                        this.options.selectMenuItemHandler(item, e);\n\n                        // it's important to stop the propagation especially for sub-menus, otherwise the event\n                        // might be handled again by top-level menu\n                        return false;\n                    });\n\n                if (item.enabled !== undefined && !item.enabled) {\n                    $item.addClass(\"disabled\");\n                }\n\n                if (item.items) {\n                    $item.addClass(\"dropdown-submenu\");\n                    $link.addClass(\"dropdown-toggle\");\n\n                    const $subMenu = $(\"<ul>\").addClass(\"dropdown-menu\");\n\n                    this.addItems($subMenu, item.items);\n\n                    $item.append($subMenu);\n                }\n\n                $parent.append($item);\n            }\n        }\n    }\n\n    hide() {\n        // this date checking comes from change in FF66 - https://github.com/zadam/trilium/issues/468\n        // \"contextmenu\" event also triggers \"click\" event which depending on the timing can close the just opened context menu\n        // we might filter out right clicks, but then it's better if even right clicks close the context menu\n        if (Date.now() - this.dateContextMenuOpenedMs > 300) {\n            // seems like if we hide the menu immediately, some clicks can get propagated to the underlying component\n            // see https://github.com/zadam/trilium/pull/3805 for details\n            setTimeout(() => this.$widget.hide(), 100);\n        }\n    }\n}\n\nconst contextMenu = new ContextMenu();\n\nexport default contextMenu;\n","import utils from \"../services/utils.js\";\nimport contextMenu from \"./context_menu.js\";\nimport imageService from \"../services/image.js\";\n\nconst PROP_NAME = \"imageContextMenuInstalled\";\n\nfunction setupContextMenu($image) {\n    if (!utils.isElectron() || $image.prop(PROP_NAME)) {\n        return;\n    }\n\n    $image.prop(PROP_NAME, true);\n    $image.on('contextmenu', e => {\n        e.preventDefault();\n\n        contextMenu.show({\n            x: e.pageX,\n            y: e.pageY,\n            items: [\n                {\n                    title: \"Copy reference to clipboard\",\n                    command: \"copyImageReferenceToClipboard\",\n                    uiIcon: \"bx bx-empty\"\n                },\n                {title: \"Copy image to clipboard\", command: \"copyImageToClipboard\", uiIcon: \"bx bx-empty\"},\n            ],\n            selectMenuItemHandler: ({command}) => {\n                if (command === 'copyImageReferenceToClipboard') {\n                    imageService.copyImageReferenceToClipboard($image);\n                } else if (command === 'copyImageToClipboard') {\n                    const webContents = utils.dynamicRequire('@electron/remote').getCurrentWebContents();\n                    utils.dynamicRequire('electron');\n                    webContents.copyImageAt(e.pageX, e.pageY);\n                } else {\n                    throw new Error(`Unrecognized command '${command}'`);\n                }\n            }\n        });\n    });\n}\n\nexport default {\n    setupContextMenu\n};\n","import contextMenu from \"./context_menu.js\";\nimport appContext from \"../components/app_context.js\";\n\nfunction openContextMenu(notePath, e, viewScope = {}, hoistedNoteId = null) {\n    contextMenu.show({\n        x: e.pageX,\n        y: e.pageY,\n        items: [\n            {title: \"Open note in a new tab\", command: \"openNoteInNewTab\", uiIcon: \"bx bx-empty\"},\n            {title: \"Open note in a new split\", command: \"openNoteInNewSplit\", uiIcon: \"bx bx-dock-right\"},\n            {title: \"Open note in a new window\", command: \"openNoteInNewWindow\", uiIcon: \"bx bx-window-open\"}\n        ],\n        selectMenuItemHandler: ({command}) => {\n            if (!hoistedNoteId) {\n                hoistedNoteId = appContext.tabManager.getActiveContext().hoistedNoteId;\n            }\n\n            if (command === 'openNoteInNewTab') {\n                appContext.tabManager.openContextWithNote(notePath, { hoistedNoteId, viewScope });\n            }\n            else if (command === 'openNoteInNewSplit') {\n                const subContexts = appContext.tabManager.getActiveContext().getSubContexts();\n                const {ntxId} = subContexts[subContexts.length - 1];\n\n                appContext.triggerCommand(\"openNewNoteSplit\", {ntxId, notePath, hoistedNoteId, viewScope});\n            }\n            else if (command === 'openNoteInNewWindow') {\n                appContext.triggerCommand('openInWindow', {notePath, hoistedNoteId, viewScope});\n            }\n        }\n    });\n}\n\nexport default {\n    openContextMenu\n}\n","import ws from \"./ws.js\";\nimport froca from \"./froca.js\";\n\nasync function renderAttribute(attribute, renderIsInheritable) {\n    const isInheritable = renderIsInheritable && attribute.isInheritable ? `(inheritable)` : '';\n    const $attr = $(\"<span>\");\n\n    if (attribute.type === 'label') {\n        $attr.append(document.createTextNode(`#${attribute.name}${isInheritable}`));\n\n        if (attribute.value) {\n            $attr.append('=');\n            $attr.append(document.createTextNode(formatValue(attribute.value)));\n        }\n    } else if (attribute.type === 'relation') {\n        if (attribute.isAutoLink) {\n            return $attr;\n        }\n\n        // when the relation has just been created, then it might not have a value\n        if (attribute.value) {\n            $attr.append(document.createTextNode(`~${attribute.name}${isInheritable}=`));\n            $attr.append(await createLink(attribute.value));\n        }\n    } else {\n        ws.logError(`Unknown attr type: ${attribute.type}`);\n    }\n\n    return $attr;\n}\n\nfunction formatValue(val) {\n    if (/^[\\p{L}\\p{N}\\-_,.]+$/u.test(val)) {\n        return val;\n    }\n    else if (!val.includes('\"')) {\n        return `\"${val}\"`;\n    }\n    else if (!val.includes(\"'\")) {\n        return `'${val}'`;\n    }\n    else if (!val.includes(\"`\")) {\n        return `\\`${val}\\``;\n    }\n    else {\n        return `\"${val.replace(/\"/g, '\\\\\"')}\"`;\n    }\n}\n\nasync function createLink(noteId) {\n    const note = await froca.getNote(noteId);\n\n    if (!note) {\n        return;\n    }\n\n    return $(\"<a>\", {\n        href: `#root/${noteId}`,\n        class: 'reference-link'\n    })\n        .text(note.title);\n}\n\nasync function renderAttributes(attributes, renderIsInheritable) {\n    const $container = $('<span class=\"rendered-note-attributes\">');\n\n    for (let i = 0; i < attributes.length; i++) {\n        const attribute = attributes[i];\n\n        const $attr = await renderAttribute(attribute, renderIsInheritable);\n        $container.append($attr.html()); // .html() to get only inner HTML, we don't want any spans\n\n        if (i < attributes.length - 1) {\n            $container.append(\" \");\n        }\n    }\n\n    return $container;\n}\n\nconst HIDDEN_ATTRIBUTES = [\n    'originalFileName',\n    'fileSize',\n    'template',\n    'inherit',\n    'cssClass',\n    'iconClass',\n    'pageSize',\n    'viewType'\n];\n\nasync function renderNormalAttributes(note) {\n    const promotedDefinitionAttributes = note.getPromotedDefinitionAttributes();\n    let attrs = note.getAttributes();\n\n    if (promotedDefinitionAttributes.length > 0) {\n        attrs = attrs.filter(attr => !!promotedDefinitionAttributes.find(promAttr => promAttr.isDefinitionFor(attr)));\n    }\n    else {\n        attrs = attrs.filter(\n            attr => !attr.isDefinition()\n                 && !attr.isAutoLink\n                 && !HIDDEN_ATTRIBUTES.includes(attr.name)\n                 && attr.noteId === note.noteId\n        );\n    }\n\n    const $renderedAttributes = await renderAttributes(attrs, false);\n\n    return {\n        count: attrs.length,\n        $renderedAttributes\n    }\n}\n\nexport default {\n    renderAttribute,\n    renderAttributes,\n    renderNormalAttributes\n}\n","import ScriptContext from \"./script_context.js\";\nimport server from \"./server.js\";\nimport toastService from \"./toast.js\";\nimport froca from \"./froca.js\";\nimport utils from \"./utils.js\";\n\nasync function getAndExecuteBundle(noteId, originEntity = null, script = null, params = null) {\n    const bundle = await server.post(`script/bundle/${noteId}`, {\n        script,\n        params\n    });\n\n    return await executeBundle(bundle, originEntity);\n}\n\nasync function executeBundle(bundle, originEntity, $container) {\n    const apiContext = await ScriptContext(bundle.noteId, bundle.allNoteIds, originEntity, $container);\n\n    try {\n        return await (function () {\n            return eval(`const apiContext = this; (async function() { ${bundle.script}\\r\\n})()`);\n        }.call(apiContext));\n    }\n    catch (e) {\n        const note = await froca.getNote(bundle.noteId);\n\n        toastService.showAndLogError(`Execution of JS note \"${note.title}\" with ID ${bundle.noteId} failed with error: ${e.message}`);\n    }\n}\n\nasync function executeStartupBundles() {\n    const isMobile = utils.isMobile();\n    const scriptBundles = await server.get(\"script/startup\" + (isMobile ? \"?mobile=true\" : \"\"));\n\n    for (const bundle of scriptBundles) {\n        await executeBundle(bundle);\n    }\n}\n\nclass WidgetsByParent {\n    constructor() {\n        this.byParent = {};\n    }\n\n    add(widget) {\n        if (!widget.parentWidget) {\n            console.log(`Custom widget does not have mandatory 'parentWidget' property defined`);\n            return;\n        }\n\n        this.byParent[widget.parentWidget] = this.byParent[widget.parentWidget] || [];\n        this.byParent[widget.parentWidget].push(widget);\n    }\n\n    get(parentName) {\n        if (!this.byParent[parentName]) {\n            return [];\n        }\n\n        return this.byParent[parentName]\n            // previously, custom widgets were provided as a single instance, but that has the disadvantage\n            // for splits where we actually need multiple instaces and thus having a class to instantiate is better\n            // https://github.com/zadam/trilium/issues/4274\n            .map(w => w.prototype ? new w() : w);\n    }\n}\n\nasync function getWidgetBundlesByParent() {\n    const scriptBundles = await server.get(\"script/widgets\");\n\n    const widgetsByParent = new WidgetsByParent();\n\n    for (const bundle of scriptBundles) {\n        let widget;\n\n        try {\n            widget = await executeBundle(bundle);\n            widgetsByParent.add(widget);\n        }\n        catch (e) {\n            logError(\"Widget initialization failed: \", e);\n            continue;\n        }\n    }\n\n    return widgetsByParent;\n}\n\nexport default {\n    executeBundle,\n    getAndExecuteBundle,\n    executeStartupBundles,\n    getWidgetBundlesByParent\n}\n","import renderService from \"./render.js\";\nimport protectedSessionService from \"./protected_session.js\";\nimport protectedSessionHolder from \"./protected_session_holder.js\";\nimport libraryLoader from \"./library_loader.js\";\nimport openService from \"./open.js\";\nimport froca from \"./froca.js\";\nimport utils from \"./utils.js\";\nimport linkService from \"./link.js\";\nimport treeService from \"./tree.js\";\nimport FNote from \"../entities/fnote.js\";\nimport FAttachment from \"../entities/fattachment.js\";\nimport imageContextMenuService from \"../menus/image_context_menu.js\";\n\nlet idCounter = 1;\n\n/**\n * @param {FNote|FAttachment} entity\n * @param {object} options\n * @return {Promise<{type: string, $renderedContent: jQuery}>}\n */\nasync function getRenderedContent(entity, options = {}) {\n    options = Object.assign({\n        tooltip: false\n    }, options);\n\n    const type = getRenderingType(entity);\n    // attachment supports only image and file/pdf/audio/video\n\n    const $renderedContent = $('<div class=\"rendered-content\">');\n\n    if (type === 'text') {\n        await renderText(entity, $renderedContent);\n    }\n    else if (type === 'code') {\n        await renderCode(entity, $renderedContent);\n    }\n    else if (type === 'image' || type === 'canvas') {\n        renderImage(entity, $renderedContent, options);\n    }\n    else if (!options.tooltip && ['file', 'pdf', 'audio', 'video'].includes(type)) {\n        renderFile(entity, type, $renderedContent);\n    }\n    else if (type === 'mermaid') {\n        await renderMermaid(entity, $renderedContent);\n    }\n    else if (type === 'render') {\n        const $content = $('<div>');\n\n        await renderService.render(entity, $content, this.ctx);\n\n        $renderedContent.append($content);\n    }\n    else if (!options.tooltip && type === 'protectedSession') {\n        const $button = $(`<button class=\"btn btn-sm\"><span class=\"bx bx-log-in\"></span> Enter protected session</button>`)\n            .on('click', protectedSessionService.enterProtectedSession);\n\n        $renderedContent.append(\n            $(\"<div>\")\n                .append(\"<div>This note is protected and to access it you need to enter password.</div>\")\n                .append(\"<br/>\")\n                .append($button)\n        );\n    }\n    else if (entity instanceof FNote) {\n        $renderedContent.append(\n            $(\"<div>\")\n                .css(\"display\", \"flex\")\n                .css(\"justify-content\", \"space-around\")\n                .css(\"align-items\", \"center\")\n                .css(\"height\", \"100%\")\n                .css(\"font-size\", \"500%\")\n                .append($(\"<span>\").addClass(entity.getIcon()))\n        );\n    }\n\n    if (entity instanceof FNote) {\n        $renderedContent.addClass(entity.getCssClass());\n    }\n\n    return {\n        $renderedContent,\n        type\n    };\n}\n\n/** @param {FNote} note */\nasync function renderText(note, $renderedContent) {\n    // entity must be FNote\n    const blob = await note.getBlob();\n\n    if (!utils.isHtmlEmpty(blob.content)) {\n        $renderedContent.append($('<div class=\"ck-content\">').html(blob.content));\n\n        if ($renderedContent.find('span.math-tex').length > 0) {\n            await libraryLoader.requireLibrary(libraryLoader.KATEX);\n\n            renderMathInElement($renderedContent[0], {trust: true});\n        }\n\n        const getNoteIdFromLink = el => treeService.getNoteIdFromUrl($(el).attr('href'));\n        const referenceLinks = $renderedContent.find(\"a.reference-link\");\n        const noteIdsToPrefetch = referenceLinks.map(el => getNoteIdFromLink(el));\n        await froca.getNotes(noteIdsToPrefetch);\n\n        for (const el of referenceLinks) {\n            await linkService.loadReferenceLinkTitle($(el));\n        }\n    } else {\n        await renderChildrenList($renderedContent, note);\n    }\n}\n\n/** @param {FNote} note */\nasync function renderCode(note, $renderedContent) {\n    const blob = await note.getBlob();\n\n    $renderedContent.append($(\"<pre>\").text(blob.content));\n}\n\nfunction renderImage(entity, $renderedContent, options = {}) {\n    const encodedTitle = encodeURIComponent(entity.title);\n\n    let url;\n\n    if (entity instanceof FNote) {\n        url = `api/images/${entity.noteId}/${encodedTitle}?${Math.random()}`;\n    } else if (entity instanceof FAttachment) {\n        url = `api/attachments/${entity.attachmentId}/image/${encodedTitle}?${entity.utcDateModified}\">`;\n    }\n\n    $renderedContent // styles needed for the zoom to work well\n        .css('display', 'flex')\n        .css('align-items', 'center')\n        .css('justify-content', 'center');\n\n    const $img = $(\"<img>\")\n        .attr(\"src\", url)\n        .attr(\"id\", \"attachment-image-\" + idCounter++)\n        .css(\"max-width\", \"100%\");\n\n    $renderedContent.append($img);\n\n    if (options.imageHasZoom) {\n        libraryLoader.requireLibrary(libraryLoader.WHEEL_ZOOM).then(() => {\n            WZoom.create(`#${$img.attr(\"id\")}`, {\n                maxScale: 50,\n                speed: 1.3,\n                zoomOnClick: false\n            });\n        });\n    }\n\n    imageContextMenuService.setupContextMenu($img);\n}\n\nfunction renderFile(entity, type, $renderedContent) {\n    let entityType, entityId;\n\n    if (entity instanceof FNote) {\n        entityType = 'notes';\n        entityId = entity.noteId;\n    } else if (entity instanceof FAttachment) {\n        entityType = 'attachments';\n        entityId = entity.attachmentId;\n    } else {\n        throw new Error(`Can't recognize entity type of '${entity}'`);\n    }\n\n    const $content = $('<div style=\"display: flex; flex-direction: column; height: 100%;\">');\n\n    if (type === 'pdf') {\n        const $pdfPreview = $('<iframe class=\"pdf-preview\" style=\"width: 100%; flex-grow: 100;\"></iframe>');\n        $pdfPreview.attr(\"src\", openService.getUrlForDownload(`api/${entityType}/${entityId}/open`));\n\n        $content.append($pdfPreview);\n    } else if (type === 'audio') {\n        const $audioPreview = $('<audio controls></audio>')\n            .attr(\"src\", openService.getUrlForDownload(`api/${entityType}/${entityId}/open-partial`))\n            .attr(\"type\", entity.mime)\n            .css(\"width\", \"100%\");\n\n        $content.append($audioPreview);\n    } else if (type === 'video') {\n        const $videoPreview = $('<video controls></video>')\n            .attr(\"src\", openService.getUrlForDownload(`api/${entityType}/${entityId}/open-partial`))\n            .attr(\"type\", entity.mime)\n            .css(\"width\", \"100%\");\n\n        $content.append($videoPreview);\n    }\n\n    if (entityType === 'notes') {\n        // TODO: we should make this available also for attachments, but there's a problem with \"Open externally\" support\n        //       in attachment list\n        const $downloadButton = $('<button class=\"file-download btn btn-primary\" type=\"button\">Download</button>');\n        const $openButton = $('<button class=\"file-open btn btn-primary\" type=\"button\">Open</button>');\n\n        $downloadButton.on('click', () => openService.downloadFileNote(entity.noteId));\n        $openButton.on('click', () => openService.openNoteExternally(entity.noteId, entity.mime));\n        // open doesn't work for protected notes since it works through a browser which isn't in protected session\n        $openButton.toggle(!entity.isProtected);\n\n        $content.append(\n            $('<div style=\"display: flex; justify-content: space-evenly; margin-top: 5px;\">')\n                .append($downloadButton)\n                .append($openButton)\n        );\n    }\n\n    $renderedContent.append($content);\n}\n\nasync function renderMermaid(note, $renderedContent) {\n    await libraryLoader.requireLibrary(libraryLoader.MERMAID);\n\n    const blob = await note.getBlob();\n    const content = blob.content || \"\";\n\n    $renderedContent\n        .css(\"display\", \"flex\")\n        .css(\"justify-content\", \"space-around\");\n\n    const documentStyle = window.getComputedStyle(document.documentElement);\n    const mermaidTheme = documentStyle.getPropertyValue('--mermaid-theme');\n\n    mermaid.mermaidAPI.initialize({startOnLoad: false, theme: mermaidTheme.trim(), securityLevel: 'antiscript'});\n\n    try {\n        const {svg} = await mermaid.mermaidAPI.render(\"in-mermaid-graph-\" + idCounter++, content);\n\n        $renderedContent.append($(svg));\n    } catch (e) {\n        const $error = $(\"<p>The diagram could not displayed.</p>\");\n\n        $renderedContent.append($error);\n    }\n}\n\n/**\n * @param {jQuery} $renderedContent\n * @param {FNote} note\n * @returns {Promise<void>}\n */\nasync function renderChildrenList($renderedContent, note) {\n    $renderedContent.css(\"padding\", \"10px\");\n    $renderedContent.addClass(\"text-with-ellipsis\");\n\n    let childNoteIds = note.getChildNoteIds();\n\n    if (childNoteIds.length > 10) {\n        childNoteIds = childNoteIds.slice(0, 10);\n    }\n\n    // just load the first 10 child notes\n    const childNotes = await froca.getNotes(childNoteIds);\n\n    for (const childNote of childNotes) {\n        $renderedContent.append(await linkService.createLink(`${note.noteId}/${childNote.noteId}`, {\n            showTooltip: false,\n            showNoteIcon: true\n        }));\n\n        $renderedContent.append(\"<br>\");\n    }\n}\n\nfunction getRenderingType(entity) {\n    let type = entity.type || entity.role;\n    const mime = entity.mime;\n\n    if (type === 'file' && mime === 'application/pdf') {\n        type = 'pdf';\n    } else if (type === 'file' && mime.startsWith('audio/')) {\n        type = 'audio';\n    } else if (type === 'file' && mime.startsWith('video/')) {\n        type = 'video';\n    }\n\n    if (entity.isProtected) {\n        if (protectedSessionHolder.isProtectedSessionAvailable()) {\n            protectedSessionHolder.touchProtectedSession();\n        }\n        else {\n            type = 'protectedSession';\n        }\n    }\n\n    return type;\n}\n\nexport default {\n    getRenderedContent\n};\n","import froca from \"./froca.js\";\nimport server from \"./server.js\";\nimport ws from \"./ws.js\";\n\n/** @returns {FNote} */\nasync function getInboxNote() {\n    const note = await server.get(`special-notes/inbox/${dayjs().format(\"YYYY-MM-DD\")}`, \"date-note\");\n\n    return await froca.getNote(note.noteId);\n}\n\n/** @returns {FNote} */\nasync function getTodayNote() {\n    return await getDayNote(dayjs().format(\"YYYY-MM-DD\"));\n}\n\n/** @returns {FNote} */\nasync function getDayNote(date) {\n    const note = await server.get(`special-notes/days/${date}`, \"date-note\");\n\n    await ws.waitForMaxKnownEntityChangeId();\n\n    return await froca.getNote(note.noteId);\n}\n\n/** @returns {FNote} */\nasync function getWeekNote(date) {\n    const note = await server.get(`special-notes/weeks/${date}`, \"date-note\");\n\n    await ws.waitForMaxKnownEntityChangeId();\n\n    return await froca.getNote(note.noteId);\n}\n\n/** @returns {FNote} */\nasync function getMonthNote(month) {\n    const note = await server.get(`special-notes/months/${month}`, \"date-note\");\n\n    await ws.waitForMaxKnownEntityChangeId();\n\n    return await froca.getNote(note.noteId);\n}\n\n/** @returns {FNote} */\nasync function getYearNote(year) {\n    const note = await server.get(`special-notes/years/${year}`, \"date-note\");\n\n    await ws.waitForMaxKnownEntityChangeId();\n\n    return await froca.getNote(note.noteId);\n}\n\n/** @returns {FNote} */\nasync function createSqlConsole() {\n    const note = await server.post('special-notes/sql-console');\n\n    await ws.waitForMaxKnownEntityChangeId();\n\n    return await froca.getNote(note.noteId);\n}\n\n/** @returns {FNote} */\nasync function createSearchNote(opts = {}) {\n    const note = await server.post('special-notes/search-note', opts);\n\n    await ws.waitForMaxKnownEntityChangeId();\n\n    return await froca.getNote(note.noteId);\n}\n\nexport default {\n    getInboxNote,\n    getTodayNote,\n    getDayNote,\n    getWeekNote,\n    getMonthNote,\n    getYearNote,\n    createSqlConsole,\n    createSearchNote\n}\n","import appContext from \"../components/app_context.js\";\n\nasync function info(message) {\n    return new Promise(res =>\n        appContext.triggerCommand(\"showInfoDialog\", {message, callback: res}));\n}\n\nasync function confirm(message) {\n    return new Promise(res =>\n        appContext.triggerCommand(\"showConfirmDialog\", {\n            message,\n            callback: x => res(x.confirmed)\n        }));\n}\n\nasync function confirmDeleteNoteBoxWithNote(title) {\n    return new Promise(res =>\n        appContext.triggerCommand(\"showConfirmDeleteNoteBoxWithNoteDialog\", {title, callback: res}));\n}\n\nasync function prompt(props) {\n    return new Promise(res =>\n        appContext.triggerCommand(\"showPromptDialog\", {...props, callback: res}));\n}\n\nexport default {\n    info,\n    confirm,\n    confirmDeleteNoteBoxWithNote,\n    prompt\n};\n","export default class FBlob {\n    constructor(row) {\n        /** @type {string} */\n        this.blobId = row.blobId;\n\n        /**\n         * can either contain the whole content (in e.g. string notes), only part (large text notes) or nothing at all (binary notes, images)\n         * @type {string}\n         */\n        this.content = row.content;\n        this.contentLength = row.contentLength;\n\n        /** @type {string} */\n        this.dateModified = row.dateModified;\n        /** @type {string} */\n        this.utcDateModified = row.utcDateModified;\n    }\n\n    /**\n     * @returns {*}\n     * @throws Error in case of invalid JSON */\n    getJsonContent() {\n        if (!this.content || !this.content.trim()) {\n            return null;\n        }\n\n        return JSON.parse(this.content);\n    }\n\n    /** @returns {*|null} valid object or null if the content cannot be parsed as JSON */\n    getJsonContentSafely() {\n        try {\n            return this.getJsonContent();\n        }\n        catch (e) {\n            return null;\n        }\n    }\n}\n","import FBranch from \"../entities/fbranch.js\";\nimport FNote from \"../entities/fnote.js\";\nimport FAttribute from \"../entities/fattribute.js\";\nimport server from \"./server.js\";\nimport appContext from \"../components/app_context.js\";\nimport FBlob from \"../entities/fblob.js\";\nimport FAttachment from \"../entities/fattachment.js\";\n\n/**\n * Froca (FROntend CAche) keeps a read only cache of note tree structure in frontend's memory.\n * - notes are loaded lazily when unknown noteId is requested\n * - when note is loaded, all its parent and child branches are loaded as well. For a branch to be used, it's not must be loaded before\n * - deleted notes are present in the cache as well, but they don't have any branches. As a result check for deleted branch is done by presence check - if the branch is not there even though the corresponding note has been loaded, we can infer it is deleted.\n *\n * Note and branch deletions are corner cases and usually not needed.\n *\n * Backend has a similar cache called Becca\n */\nclass Froca {\n    constructor() {\n        this.initializedPromise = this.loadInitialTree();\n    }\n\n    async loadInitialTree() {\n        const resp = await server.get('tree');\n\n        // clear the cache only directly before adding new content which is important for e.g., switching to protected session\n\n        /** @type {Object.<string, FNote>} */\n        this.notes = {};\n\n        /** @type {Object.<string, FBranch>} */\n        this.branches = {};\n\n        /** @type {Object.<string, FAttribute>} */\n        this.attributes = {};\n\n        /** @type {Object.<string, FAttachment>} */\n        this.attachments = {};\n\n        /** @type {Object.<string, Promise<FBlob>>} */\n        this.blobPromises = {};\n\n        this.addResp(resp);\n    }\n\n    async loadSubTree(subTreeNoteId) {\n        const resp = await server.get(`tree?subTreeNoteId=${subTreeNoteId}`);\n\n        this.addResp(resp);\n\n        return this.notes[subTreeNoteId];\n    }\n\n    addResp(resp) {\n        const noteRows = resp.notes;\n        const branchRows = resp.branches;\n        const attributeRows = resp.attributes;\n\n        const noteIdsToSort = new Set();\n\n        for (const noteRow of noteRows) {\n            const {noteId} = noteRow;\n\n            let note = this.notes[noteId];\n\n            if (note) {\n                note.update(noteRow);\n\n                // search note doesn't have child branches in the database and all the children are virtual branches\n                if (note.type !== 'search') {\n                    for (const childNoteId of note.children) {\n                        const childNote = this.notes[childNoteId];\n\n                        if (childNote) {\n                            childNote.parents = childNote.parents.filter(p => p !== noteId);\n\n                            delete this.branches[childNote.parentToBranch[noteId]];\n                            delete childNote.parentToBranch[noteId];\n                        }\n                    }\n\n                    note.children = [];\n                    note.childToBranch = {};\n                }\n\n                // we want to remove all \"real\" branches (represented in the database) since those will be created\n                // from branches argument but want to preserve all virtual ones from saved search\n                note.parents = note.parents.filter(parentNoteId => {\n                    const parentNote = this.notes[parentNoteId];\n                    const branch = this.branches[parentNote.childToBranch[noteId]];\n\n                    if (!parentNote || !branch) {\n                        return false;\n                    }\n\n                    if (branch.fromSearchNote) {\n                        return true;\n                    }\n\n                    parentNote.children = parentNote.children.filter(p => p !== noteId);\n\n                    delete this.branches[parentNote.childToBranch[noteId]];\n                    delete parentNote.childToBranch[noteId];\n\n                    return false;\n                });\n            }\n            else {\n                this.notes[noteId] = new FNote(this, noteRow);\n            }\n        }\n\n        for (const branchRow of branchRows) {\n            const branch = new FBranch(this, branchRow);\n\n            this.branches[branch.branchId] = branch;\n\n            const childNote = this.notes[branch.noteId];\n\n            if (childNote) {\n                childNote.addParent(branch.parentNoteId, branch.branchId, false);\n            }\n\n            const parentNote = this.notes[branch.parentNoteId];\n\n            if (parentNote) {\n                parentNote.addChild(branch.noteId, branch.branchId, false);\n\n                noteIdsToSort.add(parentNote.noteId);\n            }\n        }\n\n        for (const attributeRow of attributeRows) {\n            const {attributeId} = attributeRow;\n\n            this.attributes[attributeId] = new FAttribute(this, attributeRow);\n\n            const note = this.notes[attributeRow.noteId];\n\n            if (note && !note.attributes.includes(attributeId)) {\n                note.attributes.push(attributeId);\n            }\n\n            if (attributeRow.type === 'relation') {\n                const targetNote = this.notes[attributeRow.value];\n\n                if (targetNote) {\n                    if (!targetNote.targetRelations.includes(attributeId)) {\n                        targetNote.targetRelations.push(attributeId);\n                    }\n                }\n            }\n        }\n\n        // sort all of them at once, this avoids repeated sorts (#1480)\n        for (const noteId of noteIdsToSort) {\n            this.notes[noteId].sortChildren();\n            this.notes[noteId].sortParents();\n        }\n    }\n\n    async reloadNotes(noteIds) {\n        if (noteIds.length === 0) {\n            return;\n        }\n\n        noteIds = Array.from(new Set(noteIds)); // make noteIds unique\n\n        const resp = await server.post('tree/load', { noteIds });\n\n        this.addResp(resp);\n\n        appContext.triggerEvent('notesReloaded', {noteIds});\n    }\n\n    async loadSearchNote(noteId) {\n        const note = await this.getNote(noteId);\n\n        if (!note || note.type !== 'search') {\n            return;\n        }\n\n        const {searchResultNoteIds, highlightedTokens, error} = await server.get(`search-note/${note.noteId}`);\n\n        if (!Array.isArray(searchResultNoteIds)) {\n            throw new Error(`Search note '${note.noteId}' failed: ${searchResultNoteIds}`);\n        }\n\n        // reset all the virtual branches from old search results\n        if (note.noteId in froca.notes) {\n            froca.notes[note.noteId].children = [];\n            froca.notes[note.noteId].childToBranch = {};\n        }\n\n        const branches = [...note.getParentBranches(), ...note.getChildBranches()];\n\n        searchResultNoteIds.forEach((resultNoteId, index) => branches.push({\n            // branchId should be repeatable since sometimes we reload some notes without rerendering the tree\n            branchId: `virt-${note.noteId}-${resultNoteId}`,\n            noteId: resultNoteId,\n            parentNoteId: note.noteId,\n            notePosition: (index + 1) * 10,\n            fromSearchNote: true\n        }));\n\n        // update this note with standard (parent) branches + virtual (children) branches\n        this.addResp({\n            notes: [note],\n            branches,\n            attributes: []\n        });\n\n        froca.notes[note.noteId].searchResultsLoaded = true;\n        froca.notes[note.noteId].highlightedTokens = highlightedTokens;\n\n        return {error};\n    }\n\n    /** @returns {FNote[]} */\n    getNotesFromCache(noteIds, silentNotFoundError = false) {\n        return noteIds.map(noteId => {\n            if (!this.notes[noteId] && !silentNotFoundError) {\n                console.trace(`Can't find note '${noteId}'`);\n\n                return null;\n            }\n            else {\n                return this.notes[noteId];\n            }\n        }).filter(note => !!note);\n    }\n\n    /** @returns {Promise<FNote[]>} */\n    async getNotes(noteIds, silentNotFoundError = false) {\n        noteIds = Array.from(new Set(noteIds)); // make unique\n        const missingNoteIds = noteIds.filter(noteId => !this.notes[noteId]);\n\n        await this.reloadNotes(missingNoteIds);\n\n        return noteIds.map(noteId => {\n            if (!this.notes[noteId] && !silentNotFoundError) {\n                console.trace(`Can't find note '${noteId}'`);\n\n                return null;\n            } else {\n                return this.notes[noteId];\n            }\n        }).filter(note => !!note);\n    }\n\n    /** @returns {Promise<boolean>} */\n    async noteExists(noteId) {\n        const notes = await this.getNotes([noteId], true);\n\n        return notes.length === 1;\n    }\n\n    /** @returns {Promise<FNote>} */\n    async getNote(noteId, silentNotFoundError = false) {\n        if (noteId === 'none') {\n            console.trace(`No 'none' note.`);\n            return null;\n        }\n        else if (!noteId) {\n            console.trace(`Falsy noteId '${noteId}', returning null.`);\n            return null;\n        }\n\n        return (await this.getNotes([noteId], silentNotFoundError))[0];\n    }\n\n    /** @returns {FNote|null} */\n    getNoteFromCache(noteId) {\n        if (!noteId) {\n            throw new Error(\"Empty noteId\");\n        }\n\n        return this.notes[noteId];\n    }\n\n    /** @returns {FBranch[]} */\n    getBranches(branchIds, silentNotFoundError = false) {\n        return branchIds\n            .map(branchId => this.getBranch(branchId, silentNotFoundError))\n            .filter(b => !!b);\n    }\n\n    /** @returns {FBranch} */\n    getBranch(branchId, silentNotFoundError = false) {\n        if (!(branchId in this.branches)) {\n            if (!silentNotFoundError) {\n                logError(`Not existing branch '${branchId}'`);\n            }\n        }\n        else {\n            return this.branches[branchId];\n        }\n    }\n\n    async getBranchId(parentNoteId, childNoteId) {\n        if (childNoteId === 'root') {\n            return 'none_root';\n        }\n\n        const child = await this.getNote(childNoteId);\n\n        if (!child) {\n            logError(`Could not find branchId for parent '${parentNoteId}', child '${childNoteId}' since child does not exist`);\n\n            return null;\n        }\n\n        return child.parentToBranch[parentNoteId];\n    }\n\n    /** @returns {Promise<FAttachment>} */\n    async getAttachment(attachmentId, silentNotFoundError = false) {\n        const attachment = this.attachments[attachmentId];\n        if (attachment) {\n            return attachment;\n        }\n\n        // load all attachments for the given note even if one is requested, don't load one by one\n        let attachmentRows;\n        try {\n            attachmentRows = await server.getWithSilentNotFound(`attachments/${attachmentId}/all`);\n        }\n        catch (e) {\n            if (silentNotFoundError) {\n                logInfo(`Attachment '${attachmentId}' not found, but silentNotFoundError is enabled: ` + e.message);\n                return null;\n            } else {\n                throw e;\n            }\n        }\n\n        const attachments = this.processAttachmentRows(attachmentRows);\n\n        if (attachments.length) {\n            attachments[0].getNote().attachments = attachments;\n        }\n\n        return this.attachments[attachmentId];\n    }\n\n    /** @returns {Promise<FAttachment[]>} */\n    async getAttachmentsForNote(noteId) {\n        const attachmentRows = await server.get(`notes/${noteId}/attachments`);\n        return this.processAttachmentRows(attachmentRows);\n    }\n\n    /** @returns {FAttachment[]} */\n    processAttachmentRows(attachmentRows) {\n        return attachmentRows.map(attachmentRow => {\n            let attachment;\n\n            if (attachmentRow.attachmentId in this.attachments) {\n                attachment = this.attachments[attachmentRow.attachmentId];\n                attachment.update(attachmentRow);\n            } else {\n                attachment = new FAttachment(this, attachmentRow);\n                this.attachments[attachment.attachmentId] = attachment;\n            }\n\n            return attachment;\n        });\n    }\n\n    /** @returns {Promise<FBlob>} */\n    async getBlob(entityType, entityId) {\n        // I'm not sure why we're not using blobIds directly, it would save us this composite key ...\n        // perhaps one benefit is that we're always requesting the latest blob, not relying on perhaps faulty/slow\n        // websocket update?\n        const key = `${entityType}-${entityId}`;\n\n        if (!this.blobPromises[key]) {\n            this.blobPromises[key] = server.get(`${entityType}/${entityId}/blob`)\n                .then(row => new FBlob(row))\n                .catch(e => console.error(`Cannot get blob for ${entityType} '${entityId}'`, e));\n\n            // we don't want to keep large payloads forever in memory, so we clean that up quite quickly\n            // this cache is more meant to share the data between different components within one business transaction (e.g. loading of the note into the tab context and all the components)\n            // if the blob is updated within the cache lifetime, it should be invalidated by froca_updater\n            this.blobPromises[key].then(\n                () => setTimeout(() => this.blobPromises[key] = null, 1000)\n            );\n        }\n\n        return await this.blobPromises[key];\n    }\n}\n\nconst froca = new Froca();\n\nexport default froca;\n","import appContext from \"../components/app_context.js\";\nimport treeService from \"./tree.js\";\nimport dialogService from \"./dialog.js\";\nimport froca from \"./froca.js\";\n\nfunction getHoistedNoteId() {\n    const activeNoteContext = appContext.tabManager.getActiveContext();\n\n    return activeNoteContext ? activeNoteContext.hoistedNoteId : 'root';\n}\n\nasync function unhoist() {\n    const activeNoteContext = appContext.tabManager.getActiveContext();\n\n    if (activeNoteContext) {\n        await activeNoteContext.unhoist();\n    }\n}\n\nfunction isTopLevelNode(node) {\n    return isHoistedNode(node.getParent());\n}\n\nfunction isHoistedNode(node) {\n    // even though check for 'root' should not be necessary, we keep it just in case\n    return node.data.noteId === \"root\"\n        || node.data.noteId === getHoistedNoteId();\n}\n\nasync function isHoistedInHiddenSubtree() {\n    const hoistedNoteId = getHoistedNoteId();\n\n    if (hoistedNoteId === 'root') {\n        return false;\n    }\n\n    const hoistedNote = await froca.getNote(hoistedNoteId);\n    return hoistedNote.isHiddenCompletely();\n}\n\nasync function checkNoteAccess(notePath, noteContext) {\n    const resolvedNotePath = await treeService.resolveNotePath(notePath, noteContext.hoistedNoteId);\n\n    if (!resolvedNotePath) {\n        console.log(`Cannot activate '${notePath}'`);\n        return false;\n    }\n\n    const hoistedNoteId = noteContext.hoistedNoteId;\n\n    if (!resolvedNotePath.includes(hoistedNoteId) && (!resolvedNotePath.includes('_hidden') || resolvedNotePath.includes('_lbBookmarks'))) {\n        const requestedNote = await froca.getNote(treeService.getNoteIdFromUrl(resolvedNotePath));\n        const hoistedNote = await froca.getNote(hoistedNoteId);\n\n        if ((!hoistedNote.hasAncestor('_hidden') || resolvedNotePath.includes('_lbBookmarks'))\n            && !await dialogService.confirm(`Requested note '${requestedNote.title}' is outside of hoisted note '${hoistedNote.title}' subtree and you must unhoist to access the note. Do you want to proceed with unhoisting?`)) {\n            return false;\n        }\n\n        // unhoist so we can activate the note\n        await unhoist();\n    }\n\n    return true;\n}\n\nexport default {\n    getHoistedNoteId,\n    unhoist,\n    isTopLevelNode,\n    isHoistedNode,\n    checkNoteAccess,\n    isHoistedInHiddenSubtree\n}\n","import toastService from \"./toast.js\";\n\nfunction copyImageReferenceToClipboard($imageWrapper) {\n    try {\n        $imageWrapper.attr('contenteditable', 'true');\n        selectImage($imageWrapper.get(0));\n\n        const success = document.execCommand('copy');\n\n        if (success) {\n            toastService.showMessage(\"Image copied to the clipboard\");\n        } else {\n            toastService.showAndLogError(\"Could not copy the image to clipboard.\");\n        }\n    }\n    finally {\n        window.getSelection().removeAllRanges();\n        $imageWrapper.removeAttr('contenteditable');\n    }\n}\n\nfunction selectImage(element) {\n    const selection = window.getSelection();\n    const range = document.createRange();\n    range.selectNodeContents(element);\n    selection.removeAllRanges();\n    selection.addRange(range);\n}\n\nexport default {\n    copyImageReferenceToClipboard\n};\n","import server from \"./server.js\";\nimport appContext from \"../components/app_context.js\";\nimport shortcutService from \"./shortcuts.js\";\n\nconst keyboardActionRepo = {};\n\nconst keyboardActionsLoaded = server.get('keyboard-actions').then(actions => {\n\tactions = actions.filter(a => !!a.actionName); // filter out separators\n\n\tfor (const action of actions) {\n\t\taction.effectiveShortcuts = action.effectiveShortcuts.filter(shortcut => !shortcut.startsWith(\"global:\"));\n\n\t\tkeyboardActionRepo[action.actionName] = action;\n\t}\n\n\treturn actions;\n});\n\nasync function getActions() {\n\treturn await keyboardActionsLoaded;\n}\n\nasync function getActionsForScope(scope) {\n\tconst actions = await keyboardActionsLoaded;\n\n\treturn actions.filter(action => action.scope === scope);\n}\n\nasync function setupActionsForElement(scope, $el, component) {\n\tconst actions = await getActionsForScope(scope);\n\n\tfor (const action of actions) {\n\t\tfor (const shortcut of action.effectiveShortcuts) {\n\t\t\tshortcutService.bindElShortcut($el, shortcut, () => component.triggerCommand(action.actionName, {ntxId: appContext.tabManager.activeNtxId}));\n\t\t}\n\t}\n}\n\ngetActionsForScope(\"window\").then(actions => {\n\tfor (const action of actions) {\n\t\tfor (const shortcut of action.effectiveShortcuts) {\n\t\t\tshortcutService.bindGlobalShortcut(shortcut, () => appContext.triggerCommand(action.actionName, {ntxId: appContext.tabManager.activeNtxId}));\n\t\t}\n\t}\n});\n\nasync function getAction(actionName, silent = false) {\n\tawait keyboardActionsLoaded;\n\n\tconst action = keyboardActionRepo[actionName];\n\n\tif (!action) {\n\t\tif (silent) {\n\t\t\tconsole.debug(`Cannot find action '${actionName}'`);\n\t\t}\n\t\telse {\n\t\t\tthrow new Error(`Cannot find action '${actionName}'`);\n\t\t}\n\t}\n\n\treturn action;\n}\n\nfunction updateDisplayedShortcuts($container) {\n\t$container.find('kbd[data-command]').each(async (i, el) => {\n\t\tconst actionName = $(el).attr('data-command');\n\t\tconst action = await getAction(actionName, true);\n\n\t\tif (action) {\n\t\t\tconst keyboardActions = action.effectiveShortcuts.join(', ');\n\n\t\t\tif (keyboardActions || $(el).text() !== \"not set\") {\n\t\t\t\t$(el).text(keyboardActions);\n\t\t\t}\n\t\t}\n\t});\n\n\t$container.find('[data-trigger-command]').each(async (i, el) => {\n\t\tconst actionName = $(el).attr('data-trigger-command');\n\t\tconst action = await getAction(actionName, true);\n\n\t\tif (action) {\n\t\t\tconst title = $(el).attr('title');\n\t\t\tconst shortcuts = action.effectiveShortcuts.join(', ');\n\n\t\t\tif (title?.includes(shortcuts)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst newTitle = !title?.trim() ? shortcuts : `${title} (${shortcuts})`;\n\n\t\t\t$(el).attr('title', newTitle);\n\t\t}\n\t});\n}\n\nexport default {\n\tupdateDisplayedShortcuts,\n\tsetupActionsForElement,\n\tgetActions,\n\tgetActionsForScope\n};\n","const CKEDITOR = {\"js\": [\"libraries/ckeditor/ckeditor.js\"]};\n\nconst CODE_MIRROR = {\n    js: [\n        \"libraries/codemirror/codemirror.js\",\n        \"libraries/codemirror/addon/display/placeholder.js\",\n        \"libraries/codemirror/addon/edit/matchbrackets.js\",\n        \"libraries/codemirror/addon/edit/matchtags.js\",\n        \"libraries/codemirror/addon/fold/xml-fold.js\",\n        \"libraries/codemirror/addon/lint/lint.js\",\n        \"libraries/codemirror/addon/lint/eslint.js\",\n        \"libraries/codemirror/addon/mode/loadmode.js\",\n        \"libraries/codemirror/addon/mode/multiplex.js\",\n        \"libraries/codemirror/addon/mode/overlay.js\",\n        \"libraries/codemirror/addon/mode/simple.js\",\n        \"libraries/codemirror/addon/search/match-highlighter.js\",\n        \"libraries/codemirror/mode/meta.js\",\n        \"libraries/codemirror/keymap/vim.js\"\n    ],\n    css: [\n        \"libraries/codemirror/codemirror.css\",\n        \"libraries/codemirror/addon/lint/lint.css\"\n    ]\n};\n\nconst ESLINT = {js: [\"libraries/eslint.js\"]};\n\nconst RELATION_MAP = {\n    js: [\n        \"libraries/jsplumb.js\",\n        \"node_modules/panzoom/dist/panzoom.min.js\"\n    ],\n    css: [\n        \"stylesheets/relation_map.css\"\n    ]\n};\n\nconst PRINT_THIS = {js: [\"node_modules/print-this/printThis.js\"]};\n\nconst CALENDAR_WIDGET = {css: [\"stylesheets/calendar.css\"]};\n\nconst KATEX = {\n    js: [ \"node_modules/katex/dist/katex.min.js\",\n        \"node_modules/katex/dist/contrib/mhchem.min.js\",\n        \"node_modules/katex/dist/contrib/auto-render.min.js\" ],\n    css: [ \"node_modules/katex/dist/katex.min.css\" ]\n};\n\nconst WHEEL_ZOOM = {\n    js: [ \"libraries/wheel-zoom.min.js\"]\n};\n\nconst FORCE_GRAPH = {\n    js: [ \"node_modules/force-graph/dist/force-graph.min.js\"]\n};\n\nconst MERMAID = {\n    js: [ \"node_modules/mermaid/dist/mermaid.min.js\" ]\n}\n\nconst EXCALIDRAW = {\n    js: [\n        \"node_modules/react/umd/react.production.min.js\",\n        \"node_modules/react-dom/umd/react-dom.production.min.js\",\n        \"node_modules/@excalidraw/excalidraw/dist/excalidraw.production.min.js\",\n    ]\n};\n\nconst MARKJS = {\n    js: [\n        \"libraries/jquery.mark.es6.min.js\"\n    ]\n};\n\nasync function requireLibrary(library) {\n    if (library.css) {\n        library.css.map(cssUrl => requireCss(cssUrl));\n    }\n\n    if (library.js) {\n        for (const scriptUrl of library.js) {\n            await requireScript(scriptUrl);\n        }\n    }\n}\n\n// we save the promises in case of the same script being required concurrently multiple times\nconst loadedScriptPromises = {};\n\nasync function requireScript(url) {\n    url = `${window.glob.assetPath}/${url}`;\n\n    if (!loadedScriptPromises[url]) {\n        loadedScriptPromises[url] = $.ajax({\n            url: url,\n            dataType: \"script\",\n            cache: true\n        });\n    }\n\n    await loadedScriptPromises[url];\n}\n\nasync function requireCss(url, prependAssetPath = true) {\n    const cssLinks = Array\n        .from(document.querySelectorAll('link'))\n        .map(el => el.href);\n\n    if (!cssLinks.some(l => l.endsWith(url))) {\n        if (prependAssetPath) {\n            url = `${window.glob.assetPath}/${url}`;\n        }\n\n        $('head').append($('<link rel=\"stylesheet\" type=\"text/css\" />').attr('href', url));\n    }\n}\n\nexport default {\n    requireCss,\n    requireLibrary,\n    CKEDITOR,\n    CODE_MIRROR,\n    ESLINT,\n    RELATION_MAP,\n    PRINT_THIS,\n    CALENDAR_WIDGET,\n    KATEX,\n    WHEEL_ZOOM,\n    FORCE_GRAPH,\n    MERMAID,\n    EXCALIDRAW,\n    MARKJS\n}\n","import treeService from './tree.js';\nimport linkContextMenuService from \"../menus/link_context_menu.js\";\nimport appContext from \"../components/app_context.js\";\nimport froca from \"./froca.js\";\nimport utils from \"./utils.js\";\n\nfunction getNotePathFromUrl(url) {\n    const notePathMatch = /#(root[A-Za-z0-9_/]*)$/.exec(url);\n\n    return notePathMatch === null ? null : notePathMatch[1];\n}\n\nasync function getLinkIcon(noteId, viewMode) {\n    let icon;\n\n    if (viewMode === 'default') {\n        const note = await froca.getNote(noteId);\n\n        icon = note.getIcon();\n    } else if (viewMode === 'source') {\n        icon = 'bx bx-code-curly';\n    } else if (viewMode === 'attachments') {\n        icon = 'bx bx-file';\n    }\n    return icon;\n}\n\nasync function createLink(notePath, options = {}) {\n    if (!notePath || !notePath.trim()) {\n        logError(\"Missing note path\");\n\n        return $(\"<span>\").text(\"[missing note]\");\n    }\n\n    if (!notePath.startsWith(\"root\")) {\n        // all note paths should start with \"root/\" (except for \"root\" itself)\n        // used, e.g., to find internal links\n        notePath = `root/${notePath}`;\n    }\n\n    const showTooltip = options.showTooltip === undefined ? true : options.showTooltip;\n    const showNotePath = options.showNotePath === undefined ? false : options.showNotePath;\n    const showNoteIcon = options.showNoteIcon === undefined ? false : options.showNoteIcon;\n    const referenceLink = options.referenceLink === undefined ? false : options.referenceLink;\n    const autoConvertToImage = options.autoConvertToImage === undefined ? false : options.autoConvertToImage;\n\n    const { noteId, parentNoteId } = treeService.getNoteIdAndParentIdFromUrl(notePath);\n    const viewScope = options.viewScope || {};\n    const viewMode = viewScope.viewMode || 'default';\n    let linkTitle = options.title;\n\n    if (!linkTitle) {\n        if (viewMode === 'attachments' && viewScope.attachmentId) {\n            const attachment = await froca.getAttachment(viewScope.attachmentId);\n\n            linkTitle = attachment ? attachment.title : '[missing attachment]';\n        } else {\n            linkTitle = await treeService.getNoteTitle(noteId, parentNoteId);\n        }\n    }\n\n    const note = await froca.getNote(noteId);\n\n    if (autoConvertToImage && ['image', 'canvas', 'mermaid'].includes(note.type) && viewMode === 'default') {\n        const encodedTitle = encodeURIComponent(linkTitle);\n\n        return $(\"<img>\")\n            .attr(\"src\", `api/images/${noteId}/${encodedTitle}?${Math.random()}`)\n            .attr(\"alt\", linkTitle);\n    }\n\n    const $container = $(\"<span>\");\n\n    if (showNoteIcon) {\n        let icon = await getLinkIcon(noteId, viewMode);\n\n        if (icon) {\n            $container\n                .append($(\"<span>\").addClass(`bx ${icon}`))\n                .append(\" \");\n        }\n    }\n\n    const hash = calculateHash({\n        notePath,\n        viewScope: viewScope\n    });\n\n    const $noteLink = $(\"<a>\", {\n        href: hash,\n        text: linkTitle\n    });\n\n    if (!showTooltip) {\n        $noteLink.addClass(\"no-tooltip-preview\");\n    }\n\n    if (referenceLink) {\n        $noteLink.addClass(\"reference-link\");\n    }\n\n    $container.append($noteLink);\n\n    if (showNotePath) {\n        const resolvedNotePathSegments = await treeService.resolveNotePathToSegments(notePath);\n\n        if (resolvedNotePathSegments) {\n            resolvedNotePathSegments.pop(); // remove last element\n\n            const parentNotePath = resolvedNotePathSegments.join(\"/\").trim();\n\n            if (parentNotePath) {\n                $container.append($(\"<small>\").text(` (${await treeService.getNotePathTitle(parentNotePath)})`));\n            }\n        }\n    }\n\n    return $container;\n}\n\nfunction calculateHash({notePath, ntxId, hoistedNoteId, viewScope = {}}) {\n    notePath = notePath || \"\";\n    const params = [\n        ntxId ? { ntxId: ntxId } : null,\n        (hoistedNoteId && hoistedNoteId !== 'root') ? { hoistedNoteId: hoistedNoteId } : null,\n        viewScope.viewMode && viewScope.viewMode !== 'default' ? { viewMode: viewScope.viewMode } : null,\n        viewScope.attachmentId ? { attachmentId: viewScope.attachmentId } : null\n    ].filter(p => !!p);\n\n    const paramStr = params.map(pair => {\n        const name = Object.keys(pair)[0];\n        const value = pair[name];\n\n        return `${encodeURIComponent(name)}=${encodeURIComponent(value)}`;\n    }).join(\"&\");\n\n    if (!notePath && !paramStr) {\n        return \"\";\n    }\n\n    let hash = `#${notePath}`;\n\n    if (paramStr) {\n        hash += `?${paramStr}`;\n    }\n\n    return hash;\n}\n\nfunction parseNavigationStateFromUrl(url) {\n    if (!url) {\n        return {};\n    }\n\n    const hashIdx = url.indexOf('#');\n    if (hashIdx === -1) {\n        return {};\n    }\n\n    const hash = url.substr(hashIdx + 1); // strip also the initial '#'\n    const [notePath, paramString] = hash.split(\"?\");\n\n    if (!notePath.match(/^[_a-z0-9]{4,}(\\/[_a-z0-9]{4,})*$/i)) {\n        return {};\n    }\n\n    const viewScope = {\n        viewMode: 'default'\n    };\n    let ntxId = null;\n    let hoistedNoteId = null;\n    let searchString = null;\n\n    if (paramString) {\n        for (const pair of paramString.split(\"&\")) {\n            let [name, value] = pair.split(\"=\");\n            name = decodeURIComponent(name);\n            value = decodeURIComponent(value);\n\n            if (name === 'ntxId') {\n                ntxId = value;\n            } else if (name === 'hoistedNoteId') {\n                hoistedNoteId = value;\n            } else if (name === 'searchString') {\n                searchString = value; // supports triggering search from URL, e.g. #?searchString=blabla\n            } else if (['viewMode', 'attachmentId'].includes(name)) {\n                viewScope[name] = value;\n            } else {\n                console.warn(`Unrecognized hash parameter '${name}'.`);\n            }\n        }\n    }\n\n    return {\n        notePath,\n        noteId: treeService.getNoteIdFromUrl(notePath),\n        ntxId,\n        hoistedNoteId,\n        viewScope,\n        searchString\n    };\n}\n\nfunction goToLink(evt) {\n    const $link = $(evt.target).closest(\"a,.block-link\");\n    const hrefLink = $link.attr('href') || $link.attr('data-href');\n\n    return goToLinkExt(evt, hrefLink, $link);\n}\n\nfunction goToLinkExt(evt, hrefLink, $link) {\n    if (hrefLink?.startsWith(\"data:\")) {\n        return true;\n    }\n\n    evt.preventDefault();\n    evt.stopPropagation();\n\n    const {notePath, viewScope} = parseNavigationStateFromUrl(hrefLink);\n\n    const ctrlKey = utils.isCtrlKey(evt);\n    const isLeftClick = evt.which === 1;\n    const isMiddleClick = evt.which === 2;\n    const openInNewTab = (isLeftClick && ctrlKey) || isMiddleClick;\n\n    const leftClick = evt.which === 1;\n    const middleClick = evt.which === 2;\n\n    if (notePath) {\n        if (openInNewTab) {\n            appContext.tabManager.openTabWithNoteWithHoisting(notePath, {viewScope});\n        } else if (isLeftClick) {\n            const ntxId = $(evt.target).closest(\"[data-ntx-id]\").attr(\"data-ntx-id\");\n\n            const noteContext = ntxId\n                ? appContext.tabManager.getNoteContextById(ntxId)\n                : appContext.tabManager.getActiveContext();\n\n            noteContext.setNote(notePath, {viewScope}).then(() => {\n                if (noteContext !== appContext.tabManager.getActiveContext()) {\n                    appContext.tabManager.activateNoteContext(noteContext.ntxId);\n                }\n            });\n        }\n    } else if (hrefLink) {\n        const withinEditLink = $link?.hasClass(\"ck-link-actions__preview\");\n        const outsideOfCKEditor = !$link || $link.closest(\"[contenteditable]\").length === 0;\n\n        if (openInNewTab\n            || (withinEditLink && (leftClick || middleClick))\n            || (outsideOfCKEditor && (leftClick || middleClick))\n        ) {\n            if (hrefLink.toLowerCase().startsWith('http') || hrefLink.startsWith(\"api/\")) {\n                window.open(hrefLink, '_blank');\n            } else if (hrefLink.toLowerCase().startsWith('file:') && utils.isElectron()) {\n                const electron = utils.dynamicRequire('electron');\n\n                electron.shell.openPath(hrefLink);\n            }\n        }\n    }\n\n    return true;\n}\n\nfunction linkContextMenu(e) {\n    const $link = $(e.target).closest(\"a\");\n    const url = $link.attr(\"href\") || $link.attr(\"data-href\");\n\n    const { notePath, viewScope } = parseNavigationStateFromUrl(url);\n\n    if (!notePath) {\n        return;\n    }\n\n    e.preventDefault();\n\n    linkContextMenuService.openContextMenu(notePath, e, viewScope, null);\n}\n\nasync function loadReferenceLinkTitle($el, href = null) {\n    const $link = $el[0].tagName === 'A' ? $el : $el.find(\"a\");\n\n    href = href || $link.attr(\"href\");\n    if (!href) {\n        console.warn(\"Empty URL for parsing: \" + $el[0].outerHTML);\n        return;\n    }\n\n    const {noteId, viewScope} = parseNavigationStateFromUrl(href);\n    const note = await froca.getNote(noteId, true);\n\n    if (note) {\n        $el.addClass(note.getColorClass());\n    }\n\n    const title = await getReferenceLinkTitle(href);\n    $el.text(title);\n\n    if (note) {\n        const icon = await getLinkIcon(noteId, viewScope.viewMode);\n\n        $el.prepend($(\"<span>\").addClass(icon));\n    }\n}\n\nasync function getReferenceLinkTitle(href) {\n    const {noteId, viewScope} = parseNavigationStateFromUrl(href);\n    if (!noteId) {\n        return \"[missing note]\";\n    }\n\n    const note = await froca.getNote(noteId);\n    if (!note) {\n        return \"[missing note]\";\n    }\n\n    if (viewScope?.viewMode === 'attachments' && viewScope?.attachmentId) {\n        const attachment = await note.getAttachmentById(viewScope.attachmentId);\n\n        return attachment ? attachment.title : \"[missing attachment]\";\n    } else {\n        return note.title;\n    }\n}\n\nfunction getReferenceLinkTitleSync(href) {\n    const {noteId, viewScope} = parseNavigationStateFromUrl(href);\n    if (!noteId) {\n        return \"[missing note]\";\n    }\n\n    const note = froca.getNoteFromCache(noteId);\n    if (!note) {\n        return \"[missing note]\";\n    }\n\n    if (viewScope?.viewMode === 'attachments' && viewScope?.attachmentId) {\n        if (!note.attachments) {\n            return \"[loading title...]\";\n        }\n\n        const attachment = note.attachments.find(att => att.attachmentId === viewScope.attachmentId);\n\n        return attachment ? attachment.title : \"[missing attachment]\";\n    } else {\n        return note.title;\n    }\n}\n\n$(document).on('click', \"a\", goToLink);\n$(document).on('auxclick', \"a\", goToLink); // to handle the middle button\n$(document).on('contextmenu', 'a', linkContextMenu);\n$(document).on('dblclick', \"a\", e => {\n    e.preventDefault();\n    e.stopPropagation();\n\n    const $link = $(e.target).closest(\"a\");\n\n    const address = $link.attr('href');\n\n    if (address && address.startsWith('http')) {\n        window.open(address, '_blank');\n    }\n});\n\n$(document).on('mousedown', 'a', e => {\n    if (e.which === 2) {\n        // prevent paste on middle click\n        // https://github.com/zadam/trilium/issues/2995\n        // https://developer.mozilla.org/en-US/docs/Web/API/Element/auxclick_event#preventing_default_actions\n        e.preventDefault();\n        return false;\n    }\n});\n\nexport default {\n    getNotePathFromUrl,\n    createLink,\n    goToLink,\n    goToLinkExt,\n    loadReferenceLinkTitle,\n    getReferenceLinkTitle,\n    getReferenceLinkTitleSync,\n    calculateHash,\n    parseNavigationStateFromUrl\n};\n","/**\n * The purpose of this class is to cache the list of attributes for notes.\n *\n * Cache invalidation granularity is global - whenever a write operation is detected to notes, branches or attributes,\n * we invalidate the whole cache. That's OK, since the purpose for this is to speed up batch read-only operations, such\n * as loading the tree which uses attributes heavily.\n */\nclass NoteAttributeCache {\n    constructor() {\n        /** @property {Object.<string, BAttribute[]>} */\n        this.attributes = {};\n    }\n\n    invalidate() {\n        this.attributes = {};\n    }\n}\n\nconst noteAttributeCache = new NoteAttributeCache();\n\nexport default noteAttributeCache;\n","import appContext from \"../components/app_context.js\";\nimport protectedSessionHolder from \"./protected_session_holder.js\";\nimport server from \"./server.js\";\nimport ws from \"./ws.js\";\nimport froca from \"./froca.js\";\nimport treeService from \"./tree.js\";\nimport toastService from \"./toast.js\";\n\nasync function createNote(parentNotePath, options = {}) {\n    options = Object.assign({\n        activate: true,\n        focus: 'title',\n        target: 'into'\n    }, options);\n\n    // if isProtected isn't available (user didn't enter password yet), then note is created as unencrypted,\n    // but this is quite weird since the user doesn't see WHERE the note is being created, so it shouldn't occur often\n    if (!options.isProtected || !protectedSessionHolder.isProtectedSessionAvailable()) {\n        options.isProtected = false;\n    }\n\n    if (appContext.tabManager.getActiveContextNoteType() !== 'text') {\n        options.saveSelection = false;\n    }\n\n    if (options.saveSelection) {\n        [options.title, options.content] = parseSelectedHtml(options.textEditor.getSelectedHtml());\n    }\n\n    const parentNoteId = treeService.getNoteIdFromUrl(parentNotePath);\n\n    if (options.type === 'mermaid' && !options.content) {\n        options.content = `graph TD;\n    A-->B;\n    A-->C;\n    B-->D;\n    C-->D;`\n    }\n\n    const {note, branch} = await server.post(`notes/${parentNoteId}/children?target=${options.target}&targetBranchId=${options.targetBranchId || \"\"}`, {\n        title: options.title,\n        content: options.content || \"\",\n        isProtected: options.isProtected,\n        type: options.type,\n        mime: options.mime,\n        templateNoteId: options.templateNoteId\n    });\n\n    if (options.saveSelection) {\n        // we remove the selection only after it was saved to server to make sure we don't lose anything\n        options.textEditor.removeSelection();\n    }\n\n    await ws.waitForMaxKnownEntityChangeId();\n\n    if (options.activate) {\n        const activeNoteContext = appContext.tabManager.getActiveContext();\n        await activeNoteContext.setNote(`${parentNotePath}/${note.noteId}`);\n\n        if (options.focus === 'title') {\n            appContext.triggerEvent('focusAndSelectTitle', {isNewNote: true});\n        }\n        else if (options.focus === 'content') {\n            appContext.triggerEvent('focusOnDetail', {ntxId: activeNoteContext.ntxId});\n        }\n    }\n\n    const noteEntity = await froca.getNote(note.noteId);\n    const branchEntity = froca.getBranch(branch.branchId);\n\n    return {\n        note: noteEntity,\n        branch: branchEntity\n    };\n}\n\nasync function chooseNoteType() {\n    return new Promise(res => {\n        appContext.triggerCommand(\"chooseNoteType\", {callback: res});\n    });\n}\n\nasync function createNoteWithTypePrompt(parentNotePath, options = {}) {\n    const {success, noteType, templateNoteId} = await chooseNoteType();\n\n    if (!success) {\n        return;\n    }\n\n    options.type = noteType;\n    options.templateNoteId = templateNoteId;\n\n    return await createNote(parentNotePath, options);\n}\n\n/* If the first element is heading, parse it out and use it as a new heading. */\nfunction parseSelectedHtml(selectedHtml) {\n    const dom = $.parseHTML(selectedHtml);\n\n    if (dom.length > 0 && dom[0].tagName && dom[0].tagName.match(/h[1-6]/i)) {\n        const title = $(dom[0]).text();\n        // remove the title from content (only first occurrence)\n        const content = selectedHtml.replace(dom[0].outerHTML, \"\");\n\n        return [title, content];\n    }\n    else {\n        return [null, selectedHtml];\n    }\n}\n\nasync function duplicateSubtree(noteId, parentNotePath) {\n    const parentNoteId = treeService.getNoteIdFromUrl(parentNotePath);\n    const {note} = await server.post(`notes/${noteId}/duplicate/${parentNoteId}`);\n\n    await ws.waitForMaxKnownEntityChangeId();\n\n    const activeNoteContext = appContext.tabManager.getActiveContext();\n    activeNoteContext.setNote(`${parentNotePath}/${note.noteId}`);\n\n    const origNote = await froca.getNote(noteId);\n    toastService.showMessage(`Note \"${origNote.title}\" has been duplicated`);\n}\n\nexport default {\n    createNote,\n    createNoteWithTypePrompt,\n    duplicateSubtree,\n    chooseNoteType\n};\n","import treeService from \"./tree.js\";\nimport linkService from \"./link.js\";\nimport froca from \"./froca.js\";\nimport utils from \"./utils.js\";\nimport attributeRenderer from \"./attribute_renderer.js\";\nimport contentRenderer from \"./content_renderer.js\";\nimport appContext from \"../components/app_context.js\";\n\nfunction setupGlobalTooltip() {\n    $(document).on(\"mouseenter\", \"a\", mouseEnterHandler);\n\n    // close any note tooltip after click, this fixes the problem that sometimes tooltips remained on the screen\n    $(document).on(\"click\", e => {\n        if ($(e.target).closest(\".note-tooltip\").length) {\n            // click within the tooltip shouldn't close it\n            return;\n        }\n\n        $('.note-tooltip').remove();\n    });\n}\n\nfunction setupElementTooltip($el) {\n    $el.on('mouseenter', mouseEnterHandler);\n}\n\nasync function mouseEnterHandler() {\n    const $link = $(this);\n\n    if ($link.hasClass(\"no-tooltip-preview\") || $link.hasClass(\"disabled\")) {\n        return;\n    } else if ($link.closest(\".ck-link-actions\").length) {\n        // this is to avoid showing tooltip from inside the CKEditor link editor dialog\n        return;\n    } else if ($link.closest(\".note-tooltip\").length) {\n        // don't show tooltip for links within tooltip\n        return;\n    }\n\n    const url = $link.attr(\"href\") || $link.attr(\"data-href\");\n    const { notePath, noteId, viewScope } = linkService.parseNavigationStateFromUrl(url);\n\n    if (!notePath || viewScope.viewMode !== 'default') {\n        return;\n    }\n\n    const linkId = $link.attr(\"data-link-id\") || `link-${Math.floor(Math.random() * 1000000)}`;\n    $link.attr(\"data-link-id\", linkId);\n\n    if ($(`.${linkId}`).is(\":visible\")) {\n        // tooltip is already open for this link\n        return;\n    }\n\n    const note = await froca.getNote(noteId);\n\n    const [content] = await Promise.all([\n        renderTooltip(note),\n        // to reduce flicker due to accidental mouseover, cursor must stay for a bit over the link for tooltip to appear\n        new Promise(res => setTimeout(res, 500))\n    ]);\n\n    if (utils.isHtmlEmpty(content)) {\n        return;\n    }\n\n    const html = `<div class=\"note-tooltip-content\">${content}</div>`;\n    const tooltipClass = 'tooltip-' + Math.floor(Math.random() * 999_999_999);\n\n    // we need to check if we're still hovering over the element\n    // since the operation to get tooltip content was async, it is possible that\n    // we now create tooltip which won't close because it won't receive mouseleave event\n    if ($(this).filter(\":hover\").length > 0) {\n        $(this).tooltip({\n            container: 'body',\n            // https://github.com/zadam/trilium/issues/2794 https://github.com/zadam/trilium/issues/2988\n            // with bottom this flickering happens a bit less\n            placement: 'bottom',\n            trigger: 'manual',\n            boundary: 'window',\n            title: html,\n            html: true,\n            template: `<div class=\"tooltip note-tooltip ${tooltipClass}\" role=\"tooltip\"><div class=\"arrow\"></div><div class=\"tooltip-inner\"></div></div>`,\n            sanitize: false,\n            customClass: linkId\n        });\n\n        $(this).tooltip('show');\n\n        // the purpose of the code below is to:\n        // - allow user to go from hovering the link to hovering the tooltip to be able to scroll,\n        //   click on links within tooltip etc. without tooltip disappearing\n        // - once the user moves the cursor away from both link and the tooltip, hide the tooltip\n        const checkTooltip = () => {\n            if (!$(`.${tooltipClass}`).is(':visible')) {\n                console.log(\"Not visible anymore\");\n\n                return;\n            }\n\n            if (!$(this).filter(\":hover\").length && !$(`.${linkId}:hover`).length) {\n                // cursor is neither over the link nor over the tooltip, user likely is not interested\n                $(this).tooltip('dispose');\n            } else {\n                setTimeout(checkTooltip, 1000);\n            }\n        }\n\n        setTimeout(checkTooltip, 1000);\n    }\n}\n\nasync function renderTooltip(note) {\n    if (!note) {\n        return '<div>Note has been deleted.</div>';\n    }\n\n    const hoistedNoteId = appContext.tabManager.getActiveContext()?.hoistedNoteId;\n    const bestNotePath = note.getBestNotePathString(hoistedNoteId);\n\n    if (!bestNotePath) {\n        return;\n    }\n\n    let content = `<h5 class=\"note-tooltip-title\">${(await treeService.getNoteTitleWithPathAsSuffix(bestNotePath)).prop('outerHTML')}</h5>`;\n\n    const {$renderedAttributes} = await attributeRenderer.renderNormalAttributes(note);\n\n    const {$renderedContent} = await contentRenderer.getRenderedContent(note, {\n        tooltip: true,\n        trim: true\n    });\n\n    content = `${content}<div class=\"note-tooltip-attributes\">${$renderedAttributes[0].outerHTML}</div>${$renderedContent[0].outerHTML}`;\n\n    return content;\n}\n\nexport default {\n    setupGlobalTooltip,\n    setupElementTooltip\n}\n","import utils from \"./utils.js\";\nimport server from \"./server.js\";\n\nfunction checkType(type) {\n    if (type !== 'notes' && type !== 'attachments') {\n        throw new Error(`Unrecognized type '${type}', should be 'notes' or 'attachments'`);\n    }\n}\n\nfunction getFileUrl(type, noteId) {\n    checkType(type);\n\n    return getUrlForDownload(`api/${type}/${noteId}/download`);\n}\n\nfunction getOpenFileUrl(type, noteId) {\n    checkType(type);\n\n    return getUrlForDownload(`api/${type}/${noteId}/open`);\n}\n\nfunction download(url) {\n    if (utils.isElectron()) {\n        const remote = utils.dynamicRequire('@electron/remote');\n\n        remote.getCurrentWebContents().downloadURL(url);\n    } else {\n        window.location.href = url;\n    }\n}\n\nfunction downloadFileNote(noteId) {\n    const url = `${getFileUrl('notes', noteId)}?${Date.now()}`; // don't use cache\n\n    download(url);\n}\n\nfunction downloadAttachment(attachmentId) {\n    const url = `${getFileUrl('attachments', attachmentId)}?${Date.now()}`; // don't use cache\n\n    download(url);\n}\n\nasync function openCustom(type, entityId, mime) {\n    checkType(type);\n    if (!utils.isElectron() || utils.isMac()) {\n        return;\n    }\n\n    const resp = await server.post(`${type}/${entityId}/save-to-tmp-dir`);\n    let filePath = resp.tmpFilePath;\n    const {exec} = utils.dynamicRequire('child_process');\n    const platform = process.platform;\n\n    if (platform === 'linux') {\n        // we don't know which terminal is available, try in succession\n        const terminals = ['x-terminal-emulator', 'gnome-terminal', 'konsole', 'xterm', 'xfce4-terminal', 'mate-terminal', 'rxvt', 'terminator', 'terminology'];\n        const openFileWithTerminal = (terminal) => {\n            const command = `${terminal} -e 'mimeopen -d \"${filePath}\"'`;\n            console.log(`Open Note custom: ${command} `);\n            exec(command, (error, stdout, stderr) => {\n                if (error) {\n                    console.error(`Open Note custom: Failed to open file with ${terminal}: ${error}`);\n                    searchTerminal(terminals.indexOf(terminal) + 1);\n                } else {\n                    console.log(`Open Note custom: File opened with ${terminal}: ${stdout}`);\n                }\n            });\n        };\n\n        const searchTerminal = (index) => {\n            const terminal = terminals[index];\n            if (!terminal) {\n                console.error('Open Note custom: No terminal found!');\n                open(getFileUrl(entityId), {url: true});\n                return;\n            }\n            exec(`which ${terminal}`, (error, stdout, stderr) => {\n                if (stdout.trim()) {\n                    openFileWithTerminal(terminal);\n                } else {\n                    searchTerminal(index + 1);\n                }\n            });\n        };\n        searchTerminal(0);\n    } else if (platform === 'win32') {\n        if (filePath.indexOf(\"/\") !== -1) {\n            // Note that the path separator must be \\ instead of /\n            filePath = filePath.replace(/\\//g, \"\\\\\");\n        }\n        const command = `rundll32.exe shell32.dll,OpenAs_RunDLL ` + filePath;\n        exec(command, (err, stdout, stderr) => {\n            if (err) {\n                console.error(\"Open Note custom: \", err);\n                open(getFileUrl(entityId), {url: true});\n                return;\n            }\n        });\n    } else {\n        console.log('Currently \"Open Note custom\" only supports linux and windows systems');\n        open(getFileUrl(entityId), {url: true});\n    }\n}\n\nconst openNoteCustom = async (noteId, mime) => await openCustom('notes', noteId, mime);\nconst openAttachmentCustom = async (attachmentId, mime) => await openCustom('attachments', attachmentId, mime);\n\n\nfunction downloadRevision(noteId, revisionId) {\n    const url = getUrlForDownload(`api/revisions/${revisionId}/download`);\n\n    download(url);\n}\n\n/**\n * @param url - should be without initial slash!!!\n */\nfunction getUrlForDownload(url) {\n    if (utils.isElectron()) {\n        // electron needs absolute URL, so we extract current host, port, protocol\n        return `${getHost()}/${url}`;\n    }\n    else {\n        // web server can be deployed on subdomain, so we need to use a relative path\n        return url;\n    }\n}\n\nfunction canOpenInBrowser(mime) {\n    return mime === \"application/pdf\"\n        || mime.startsWith(\"image\")\n        || mime.startsWith(\"audio\")\n        || mime.startsWith(\"video\");\n}\n\nasync function openExternally(type, entityId, mime) {\n    checkType(type);\n\n    if (utils.isElectron()) {\n        const resp = await server.post(`${type}/${entityId}/save-to-tmp-dir`);\n\n        const electron = utils.dynamicRequire('electron');\n        const res = await electron.shell.openPath(resp.tmpFilePath);\n\n        if (res) {\n            // fallback in case there's no default application for this file\n            window.open(getFileUrl(type, entityId));\n        }\n    }\n    else {\n        // allow browser to handle opening common file\n        if (canOpenInBrowser(mime)) {\n            window.open(getOpenFileUrl(type, entityId));\n        } else {\n            window.location.href = getFileUrl(type, entityId);\n        }\n    }\n}\n\nconst openNoteExternally = async (noteId, mime) => await openExternally('notes', noteId, mime);\nconst openAttachmentExternally = async (attachmentId, mime) => await openExternally('attachments', attachmentId, mime);\n\nfunction getHost() {\n    const url = new URL(window.location.href);\n    return `${url.protocol}//${url.hostname}:${url.port}`;\n}\n\nexport default {\n    download,\n    downloadFileNote,\n    downloadRevision,\n    downloadAttachment,\n    getUrlForDownload,\n    openNoteExternally,\n    openAttachmentExternally,\n    openNoteCustom,\n    openAttachmentCustom,\n}\n","import server from \"./server.js\";\n\nclass Options {\n    constructor() {\n        this.initializedPromise = server.get('options').then(data => this.load(data));\n    }\n\n    load(arr) {\n        this.arr = arr;\n    }\n\n    get(key) {\n        return this.arr[key];\n    }\n\n    getNames() {\n        return Object.keys(this.arr);\n    }\n\n    getJson(key) {\n        try {\n            return JSON.parse(this.arr[key]);\n        }\n        catch (e) {\n            return null;\n        }\n    }\n\n    getInt(key) {\n        return parseInt(this.arr[key]);\n    }\n\n    getFloat(key) {\n        return parseFloat(this.arr[key]);\n    }\n\n    is(key) {\n        return this.arr[key] === 'true';\n    }\n\n    set(key, value) {\n        this.arr[key] = value;\n    }\n\n    async save(key, value) {\n        this.set(key, value);\n\n        const payload = {};\n        payload[key] = value;\n\n        await server.put(`options`, payload);\n    }\n\n    async toggle(key) {\n        await this.save(key, (!this.is(key)).toString());\n    }\n}\n\nconst options = new Options();\n\nexport default options;\n","function parse(value) {\n    const tokens = value.split(',').map(t => t.trim());\n    const defObj = {};\n\n    for (const token of tokens) {\n        if (token === 'promoted') {\n            defObj.isPromoted = true;\n        }\n        else if (['text', 'number', 'boolean', 'date', 'datetime', 'url'].includes(token)) {\n            defObj.labelType = token;\n        }\n        else if (['single', 'multi'].includes(token)) {\n            defObj.multiplicity = token;\n        }\n        else if (token.startsWith('precision')) {\n            const chunks = token.split('=');\n\n            defObj.numberPrecision = parseInt(chunks[1]);\n        }\n        else if (token.startsWith('alias')) {\n            const chunks = token.split('=');\n\n            defObj.promotedAlias = chunks[1];\n        }\n        else if (token.startsWith('inverse')) {\n            const chunks = token.split('=');\n\n            defObj.inverseRelation = chunks[1];\n        }\n        else {\n            console.log(\"Unrecognized attribute definition token:\", token);\n        }\n    }\n\n    return defObj;\n}\n\nexport default {\n    parse\n};\n","import server from './server.js';\nimport protectedSessionHolder from './protected_session_holder.js';\nimport toastService from \"./toast.js\";\nimport ws from \"./ws.js\";\nimport appContext from \"../components/app_context.js\";\nimport froca from \"./froca.js\";\nimport utils from \"./utils.js\";\nimport options from \"./options.js\";\n\nlet protectedSessionDeferred = null;\n\nasync function leaveProtectedSession() {\n    if (protectedSessionHolder.isProtectedSessionAvailable()) {\n        await protectedSessionHolder.resetProtectedSession();\n    }\n}\n\n/** returned promise resolves with true if new protected session was established, false if no action was necessary */\nfunction enterProtectedSession() {\n    const dfd = $.Deferred();\n\n    if (!options.is(\"isPasswordSet\")) {\n        appContext.triggerCommand(\"showPasswordNotSet\");\n        return dfd;\n    }\n\n    if (protectedSessionHolder.isProtectedSessionAvailable()) {\n        dfd.resolve(false);\n    }\n    else {\n        // using deferred instead of promise because it allows resolving from the outside\n        protectedSessionDeferred = dfd;\n\n        appContext.triggerCommand(\"showProtectedSessionPasswordDialog\");\n    }\n\n    return dfd.promise();\n}\n\nasync function reloadData() {\n    const allNoteIds = Object.keys(froca.notes);\n\n    await froca.loadInitialTree();\n\n    // make sure that all notes used in the application are loaded, including the ones not shown in the tree\n    await froca.reloadNotes(allNoteIds, true);\n}\n\nasync function setupProtectedSession(password) {\n    const response = await server.post('login/protected', { password: password });\n\n    if (!response.success) {\n        toastService.showError(\"Wrong password.\", 3000);\n        return;\n    }\n\n    protectedSessionHolder.enableProtectedSession();\n}\n\nws.subscribeToMessages(async message => {\n    if (message.type === 'protectedSessionLogin') {\n        await reloadData();\n\n        await appContext.triggerEvent('frocaReloaded');\n\n        appContext.triggerEvent('protectedSessionStarted');\n\n        appContext.triggerCommand(\"closeProtectedSessionPasswordDialog\");\n\n        if (protectedSessionDeferred !== null) {\n            protectedSessionDeferred.resolve(true);\n            protectedSessionDeferred = null;\n        }\n\n        toastService.showMessage(\"Protected session has been started.\");\n    }\n    else if (message.type === 'protectedSessionLogout') {\n        utils.reloadFrontendApp(`Protected session logout`);\n    }\n});\n\nasync function protectNote(noteId, protect, includingSubtree) {\n    await enterProtectedSession();\n\n    await server.put(`notes/${noteId}/protect/${protect ? 1 : 0}?subtree=${includingSubtree ? 1 : 0}`);\n}\n\nfunction makeToast(message, protectingLabel, text) {\n    return {\n        id: message.taskId,\n        title: `${protectingLabel} status`,\n        message: text,\n        icon: message.data.protect ? \"check-shield\" : \"shield\"\n    };\n}\n\nws.subscribeToMessages(async message => {\n    if (message.taskType !== 'protectNotes') {\n        return;\n    }\n\n    const protectingLabel = message.data.protect ? \"Protecting\" : \"Unprotecting\";\n\n    if (message.type === 'taskError') {\n        toastService.closePersistent(message.taskId);\n        toastService.showError(message.message);\n    } else if (message.type === 'taskProgressCount') {\n        toastService.showPersistent(makeToast(message, protectingLabel,`${protectingLabel} in progress: ${message.progressCount}`));\n    } else if (message.type === 'taskSucceeded') {\n        const toast = makeToast(message, protectingLabel, `${protectingLabel} finished successfully.`);\n        toast.closeAfter = 3000;\n\n        toastService.showPersistent(toast);\n    }\n});\n\nexport default {\n    protectNote,\n    enterProtectedSession,\n    leaveProtectedSession,\n    setupProtectedSession\n};\n","import server from \"./server.js\";\n\nfunction enableProtectedSession() {\n    glob.isProtectedSessionAvailable = true;\n\n    touchProtectedSession();\n}\n\nasync function resetProtectedSession() {\n    await server.post(\"logout/protected\");\n}\n\nfunction isProtectedSessionAvailable() {\n    return glob.isProtectedSessionAvailable;\n}\n\nasync function touchProtectedSession() {\n    if (isProtectedSessionAvailable()) {\n        await server.post(\"login/protected/touch\");\n    }\n}\n\nfunction touchProtectedSessionIfNecessary(note) {\n    if (note && note.isProtected && isProtectedSessionAvailable()) {\n        touchProtectedSession();\n    }\n}\n\nexport default {\n    enableProtectedSession,\n    resetProtectedSession,\n    isProtectedSessionAvailable,\n    touchProtectedSession,\n    touchProtectedSessionIfNecessary\n};\n","import server from \"./server.js\";\nimport bundleService from \"./bundle.js\";\n\nasync function render(note, $el) {\n    const relations = note.getRelations('renderNote');\n    const renderNoteIds = relations\n        .map(rel => rel.value)\n        .filter(noteId => noteId);\n\n    $el.empty().toggle(renderNoteIds.length > 0);\n\n    for (const renderNoteId of renderNoteIds) {\n        const bundle = await server.post(`script/bundle/${renderNoteId}`);\n\n        const $scriptContainer = $('<div>');\n        $el.append($scriptContainer);\n\n        $scriptContainer.append(bundle.html);\n\n        // async so that scripts cannot block trilium execution\n        bundleService.executeBundle(bundle, note, $scriptContainer);\n    }\n\n    return renderNoteIds.length > 0;\n}\n\nexport default {\n    render\n}\n","import server from './server.js';\nimport utils from './utils.js';\nimport toastService from './toast.js';\nimport linkService from './link.js';\nimport froca from './froca.js';\nimport noteTooltipService from './note_tooltip.js';\nimport protectedSessionService from './protected_session.js';\nimport dateNotesService from './date_notes.js';\nimport searchService from './search.js';\nimport RightPanelWidget from '../widgets/right_panel_widget.js';\nimport ws from \"./ws.js\";\nimport appContext from \"../components/app_context.js\";\nimport NoteContextAwareWidget from \"../widgets/note_context_aware_widget.js\";\nimport BasicWidget from \"../widgets/basic_widget.js\";\nimport SpacedUpdate from \"./spaced_update.js\";\nimport shortcutService from \"./shortcuts.js\";\nimport dialogService from \"./dialog.js\";\n\n\n/**\n * A whole number\n * @typedef {number} int\n */\n\n/**\n * An instance of the frontend api available globally.\n * @global\n * @var {FrontendScriptApi} api\n */\n\n/**\n * <p>This is the main frontend API interface for scripts. All the properties and methods are published in the \"api\" object\n * available in the JS frontend notes. You can use e.g. <code>api.showMessage(api.startNote.title);</code></p>\n *\n * @constructor\n */\nfunction FrontendScriptApi(startNote, currentNote, originEntity = null, $container = null) {\n    /**\n     * Container of all the rendered script content\n     * @type {jQuery}\n     * */\n    this.$container = $container;\n\n    /**\n     * Note where the script started executing, i.e., the (event) entrypoint of the current script execution.\n     * @type {FNote}\n     */\n    this.startNote = startNote;\n\n    /**\n     * Note where the script is currently executing, i.e. the note where the currently executing source code is written.\n     * @type {FNote}\n     */\n    this.currentNote = currentNote;\n\n    /**\n     * Entity whose event triggered this execution.\n     * @type {object|null}\n     */\n    this.originEntity = originEntity;\n\n    /**\n     * day.js library for date manipulation.\n     * See {@link https://day.js.org} for documentation\n     * @see https://day.js.org\n     * @type {dayjs}\n     */\n    this.dayjs = dayjs;\n\n    /** @type {RightPanelWidget} */\n    this.RightPanelWidget = RightPanelWidget;\n\n    /** @type {NoteContextAwareWidget} */\n    this.NoteContextAwareWidget = NoteContextAwareWidget;\n\n    /** @type {BasicWidget} */\n    this.BasicWidget = BasicWidget;\n\n    /**\n     * Activates note in the tree and in the note detail.\n     *\n     * @method\n     * @param {string} notePath (or noteId)\n     * @returns {Promise<void>}\n     */\n    this.activateNote = async notePath => {\n        await appContext.tabManager.getActiveContext().setNote(notePath);\n    };\n\n    /**\n     * Activates newly created note. Compared to this.activateNote() also makes sure that frontend has been fully synced.\n     *\n     * @param {string} notePath (or noteId)\n     * @returns {Promise<void>}\n     */\n    this.activateNewNote = async notePath => {\n        await ws.waitForMaxKnownEntityChangeId();\n\n        await appContext.tabManager.getActiveContext().setNote(notePath);\n        await appContext.triggerEvent('focusAndSelectTitle');\n    };\n\n    /**\n     * Open a note in a new tab.\n     *\n     * @method\n     * @param {string} notePath (or noteId)\n     * @param {boolean} activate - set to true to activate the new tab, false to stay on the current tab\n     * @returns {Promise<void>}\n     */\n    this.openTabWithNote = async (notePath, activate) => {\n        await ws.waitForMaxKnownEntityChangeId();\n\n        await appContext.tabManager.openTabWithNoteWithHoisting(notePath, { activate });\n\n        if (activate) {\n            await appContext.triggerEvent('focusAndSelectTitle');\n        }\n    };\n\n    /**\n     * Open a note in a new split.\n     *\n     * @method\n     * @param {string} notePath (or noteId)\n     * @param {boolean} activate - set to true to activate the new split, false to stay on the current split\n     * @returns {Promise<void>}\n     */\n    this.openSplitWithNote = async (notePath, activate) => {\n        await ws.waitForMaxKnownEntityChangeId();\n\n        const subContexts = appContext.tabManager.getActiveContext().getSubContexts();\n        const {ntxId} = subContexts[subContexts.length - 1];\n\n        await appContext.triggerCommand(\"openNewNoteSplit\", {ntxId, notePath});\n\n        if (activate) {\n            await appContext.triggerEvent('focusAndSelectTitle');\n        }\n    };\n\n    /**\n     * Adds a new launcher to the launchbar. If the launcher (id) already exists, it will be updated.\n     *\n     * @method\n     * @deprecated you can now create/modify launchers in the top-left Menu -> Configure Launchbar\n     *             for special needs there's also backend API's createOrUpdateLauncher()\n     * @param {object} opts\n     * @param {string} opts.title\n     * @param {function} opts.action - callback handling the click on the button\n     * @param {string} [opts.id] - id of the button, used to identify the old instances of this button to be replaced\n     *                          ID is optional because of BC, but not specifying it is deprecated. ID can be alphanumeric only.\n     * @param {string} [opts.icon] - name of the boxicon to be used (e.g. \"time\" for \"bx-time\" icon)\n     * @param {string} [opts.shortcut] - keyboard shortcut for the button, e.g. \"alt+t\"\n     */\n    this.addButtonToToolbar = async opts => {\n        console.warn(\"api.addButtonToToolbar() has been deprecated since v0.58 and may be removed in the future. Use  Menu -> Configure Launchbar to create/update launchers instead.\");\n\n        const {action, ...reqBody} = opts;\n        reqBody.action = action.toString();\n\n        await server.put('special-notes/api-script-launcher', reqBody);\n    };\n\n    function prepareParams(params) {\n        if (!params) {\n            return params;\n        }\n\n        return params.map(p => {\n            if (typeof p === \"function\") {\n                return `!@#Function: ${p.toString()}`;\n            }\n            else {\n                return p;\n            }\n        });\n    }\n\n    /**\n     * @private\n     */\n    this.__runOnBackendInner = async (func, params, transactional) => {\n        if (typeof func === \"function\") {\n            func = func.toString();\n        }\n\n        const ret = await server.post('script/exec', {\n            script: func,\n            params: prepareParams(params),\n            startNoteId: startNote.noteId,\n            currentNoteId: currentNote.noteId,\n            originEntityName: \"notes\", // currently there's no other entity on the frontend which can trigger event\n            originEntityId: originEntity ? originEntity.noteId : null,\n            transactional\n        }, \"script\");\n\n        if (ret.success) {\n            await ws.waitForMaxKnownEntityChangeId();\n\n            return ret.executionResult;\n        } else {\n            throw new Error(`server error: ${ret.error}`);\n        }\n    }\n\n    /**\n     * Executes given anonymous function on the backend.\n     * Internally this serializes the anonymous function into string and sends it to backend via AJAX.\n     * Please make sure that the supplied function is synchronous. Only sync functions will work correctly\n     * with transaction management. If you really know what you're doing, you can call api.runAsyncOnBackendWithManualTransactionHandling()\n     *\n     * @method\n     * @param {function|string} func - (synchronous) function to be executed on the backend\n     * @param {Array.<?>} params - list of parameters to the anonymous function to be sent to backend\n     * @returns {Promise<*>} return value of the executed function on the backend\n     */\n    this.runOnBackend = async (func, params = []) => {\n        if (func?.constructor.name === \"AsyncFunction\" || func?.startsWith?.(\"async \")) {\n            toastService.showError(\"You're passing an async function to api.runOnBackend() which will likely not work as you intended. \"\n                + \"Either make the function synchronous (by removing 'async' keyword), or use api.runAsyncOnBackendWithManualTransactionHandling()\");\n        }\n\n        return await this.__runOnBackendInner(func, params, true);\n    };\n\n    /**\n     * Executes given anonymous function on the backend.\n     * Internally this serializes the anonymous function into string and sends it to backend via AJAX.\n     * This function is meant for advanced needs where an async function is necessary.\n     * In this case, the automatic request-scoped transaction management is not applied,\n     * and you need to manually define transaction via api.transactional().\n     *\n     * If you have a synchronous function, please use api.runOnBackend().\n     *\n     * @method\n     * @param {function|string} func - (synchronous) function to be executed on the backend\n     * @param {Array.<?>} params - list of parameters to the anonymous function to be sent to backend\n     * @returns {Promise<*>} return value of the executed function on the backend\n     */\n    this.runAsyncOnBackendWithManualTransactionHandling = async (func, params = []) => {\n        if (func?.constructor.name === \"Function\" || func?.startsWith?.(\"function\")) {\n            toastService.showError(\"You're passing a synchronous function to api.runAsyncOnBackendWithManualTransactionHandling(), \" +\n                \"while you should likely use api.runOnBackend() instead.\");\n        }\n\n        return await this.__runOnBackendInner(func, params, false);\n    };\n\n    /**\n     * This is a powerful search method - you can search by attributes and their values, e.g.:\n     * \"#dateModified =* MONTH AND #log\". See full documentation for all options at: https://github.com/zadam/trilium/wiki/Search\n     *\n     * @method\n     * @param {string} searchString\n     * @returns {Promise<FNote[]>}\n     */\n    this.searchForNotes = async searchString => {\n        return await searchService.searchForNotes(searchString);\n    };\n\n    /**\n     * This is a powerful search method - you can search by attributes and their values, e.g.:\n     * \"#dateModified =* MONTH AND #log\". See full documentation for all options at: https://github.com/zadam/trilium/wiki/Search\n     *\n     * @method\n     * @param {string} searchString\n     * @returns {Promise<FNote|null>}\n     */\n    this.searchForNote = async searchString => {\n        const notes = await this.searchForNotes(searchString);\n\n        return notes.length > 0 ? notes[0] : null;\n    };\n\n    /**\n     * Returns note by given noteId. If note is missing from the cache, it's loaded.\n     **\n     * @method\n     * @param {string} noteId\n     * @returns {Promise<FNote>}\n     */\n    this.getNote = async noteId => await froca.getNote(noteId);\n\n    /**\n     * Returns list of notes. If note is missing from the cache, it's loaded.\n     *\n     * This is often used to bulk-fill the cache with notes which would have to be picked one by one\n     * otherwise (by e.g. createLink())\n     *\n     * @method\n     * @param {string[]} noteIds\n     * @param {boolean} [silentNotFoundError] - don't report error if the note is not found\n     * @returns {Promise<FNote[]>}\n     */\n    this.getNotes = async (noteIds, silentNotFoundError = false) => await froca.getNotes(noteIds, silentNotFoundError);\n\n    /**\n     * Update frontend tree (note) cache from the backend.\n     *\n     * @method\n     * @param {string[]} noteIds\n     */\n    this.reloadNotes = async noteIds => await froca.reloadNotes(noteIds);\n\n    /**\n     * Instance name identifies particular Trilium instance. It can be useful for scripts\n     * if some action needs to happen on only one specific instance.\n     *\n     * @method\n     * @returns {string}\n     */\n    this.getInstanceName = () => window.glob.instanceName;\n\n    /**\n     * @method\n     * @param {Date} date\n     * @returns {string} date in YYYY-MM-DD format\n     */\n    this.formatDateISO = utils.formatDateISO;\n\n    /**\n     * @method\n     * @param {string} str\n     * @returns {Date} parsed object\n     */\n    this.parseDate = utils.parseDate;\n\n    /**\n     * Show an info toast message to the user.\n     *\n     * @method\n     * @param {string} message\n     */\n    this.showMessage = toastService.showMessage;\n\n    /**\n     * Show an error toast message to the user.\n     *\n     * @method\n     * @param {string} message\n     */\n    this.showError = toastService.showError;\n\n    /**\n     * Show an info dialog to the user.\n     *\n     * @method\n     * @param {string} message\n     * @returns {Promise}\n     */\n    this.showInfoDialog = dialogService.info;\n\n    /**\n     * Show confirm dialog to the user.\n     *\n     * @method\n     * @param {string} message\n     * @returns {Promise<boolean>} promise resolving to true if the user confirmed\n     */\n    this.showConfirmDialog = dialogService.confirm;\n\n    /**\n     * Show prompt dialog to the user.\n     *\n     * @method\n     * @param {object} props\n     * @param {string} props.title\n     * @param {string} props.message\n     * @param {string} props.defaultValue\n     * @returns {Promise<string>} promise resolving to the answer provided by the user\n     */\n    this.showPromptDialog = dialogService.prompt;\n\n    /**\n     * Trigger command. This is a very low-level API which should be avoided if possible.\n     *\n     * @method\n     * @param {string} name\n     * @param {object} data\n     */\n    this.triggerCommand = (name, data) => appContext.triggerCommand(name, data);\n\n    /**\n     * Trigger event. This is a very low-level API which should be avoided if possible.\n     *\n     * @method\n     * @param {string} name\n     * @param {object} data\n     */\n    this.triggerEvent = (name, data) => appContext.triggerEvent(name, data);\n\n    /**\n     * Create a note link (jQuery object) for given note.\n     *\n     * @method\n     * @param {string} notePath (or noteId)\n     * @param {object} [params]\n     * @param {boolean} [params.showTooltip=true] - enable/disable tooltip on the link\n     * @param {boolean} [params.showNotePath=false] - show also whole note's path as part of the link\n     * @param {boolean} [params.showNoteIcon=false] - show also note icon before the title\n     * @param {string} [params.title] - custom link tile with note's title as default\n     * @param {string} [params.title=] - custom link tile with note's title as default\n     * @returns {jQuery} - jQuery element with the link (wrapped in <span>)\n     */\n    this.createLink = linkService.createLink;\n\n    /** @deprecated - use api.createLink() instead */\n    this.createNoteLink = linkService.createLink;\n\n    /**\n     * Adds given text to the editor cursor\n     *\n     * @method\n     * @param {string} text - this must be clear text, HTML is not supported.\n     */\n    this.addTextToActiveContextEditor = text => appContext.triggerCommand('addTextToActiveEditor', {text});\n\n    /**\n     * @method\n     * @returns {FNote} active note (loaded into center pane)\n     */\n    this.getActiveContextNote = () => appContext.tabManager.getActiveContextNote();\n\n    /**\n     * @method\n     * @returns {NoteContext} - returns active context (split)\n     */\n    this.getActiveContext = () => appContext.tabManager.getActiveContext();\n\n    /**\n     * @method\n     * @returns {NoteContext} - returns active main context (first split in a tab, represents the tab as a whole)\n     */\n    this.getActiveMainContext = () => appContext.tabManager.getActiveMainContext();\n\n    /**\n     * @method\n     * @returns {NoteContext[]} - returns all note contexts (splits) in all tabs\n     */\n    this.getNoteContexts = () => appContext.tabManager.getNoteContexts();\n\n    /**\n     * @method\n     * @returns {NoteContext[]} - returns all main contexts representing tabs\n     */\n    this.getMainNoteContexts = () => appContext.tabManager.getMainNoteContexts();\n\n    /**\n     * See https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editor-Editor.html for documentation on the returned instance.\n     *\n     * @method\n     * @returns {Promise<BalloonEditor>} instance of CKEditor\n     */\n    this.getActiveContextTextEditor = () => appContext.tabManager.getActiveContext()?.getTextEditor();\n\n    /**\n     * See https://codemirror.net/doc/manual.html#api\n     *\n     * @method\n     * @returns {Promise<CodeMirror>} instance of CodeMirror\n     */\n    this.getActiveContextCodeEditor = () => appContext.tabManager.getActiveContext()?.getCodeEditor();\n\n    /**\n     * Get access to the widget handling note detail. Methods like `getWidgetType()` and `getTypeWidget()` to get to the\n     * implementation of actual widget type.\n     *\n     * @method\n     * @returns {Promise<NoteDetailWidget>}\n     */\n    this.getActiveNoteDetailWidget = () => new Promise(resolve => appContext.triggerCommand('executeInActiveNoteDetailWidget', {callback: resolve}));\n\n    /**\n     * @method\n     * @returns {Promise<string|null>} returns a note path of active note or null if there isn't active note\n     */\n    this.getActiveContextNotePath = () => appContext.tabManager.getActiveContextNotePath();\n\n    /**\n     * Returns component which owns the given DOM element (the nearest parent component in DOM tree)\n     *\n     * @method\n     * @param {Element} el - DOM element\n     * @returns {Component}\n     */\n    this.getComponentByEl = el => appContext.getComponentByEl(el);\n\n    /**\n     * @method\n     * @param {object} $el - jquery object on which to set up the tooltip\n     * @returns {Promise<void>}\n     */\n    this.setupElementTooltip = noteTooltipService.setupElementTooltip;\n\n    /**\n     * @method\n     * @param {string} noteId\n     * @param {boolean} protect - true to protect note, false to unprotect\n     * @returns {Promise<void>}\n     */\n    this.protectNote = async (noteId, protect) => {\n        await protectedSessionService.protectNote(noteId, protect, false);\n    };\n\n    /**\n     * @method\n     * @param {string} noteId\n     * @param {boolean} protect - true to protect subtree, false to unprotect\n     * @returns {Promise<void>}\n     */\n    this.protectSubTree = async (noteId, protect) => {\n        await protectedSessionService.protectNote(noteId, protect, true);\n    };\n\n    /**\n     * Returns date-note for today. If it doesn't exist, it is automatically created.\n     *\n     * @method\n     * @returns {Promise<FNote>}\n     */\n    this.getTodayNote = dateNotesService.getTodayNote;\n\n    /**\n     * Returns day note for a given date. If it doesn't exist, it is automatically created.\n     *\n     * @method\n     * @param {string} date - e.g. \"2019-04-29\"\n     * @returns {Promise<FNote>}\n     */\n    this.getDayNote = dateNotesService.getDayNote;\n\n    /**\n     * Returns day note for the first date of the week of the given date. If it doesn't exist, it is automatically created.\n     *\n     * @method\n     * @param {string} date - e.g. \"2019-04-29\"\n     * @returns {Promise<FNote>}\n     */\n    this.getWeekNote = dateNotesService.getWeekNote;\n\n    /**\n     * Returns month-note. If it doesn't exist, it is automatically created.\n     *\n     * @method\n     * @param {string} month - e.g. \"2019-04\"\n     * @returns {Promise<FNote>}\n     */\n    this.getMonthNote = dateNotesService.getMonthNote;\n\n    /**\n     * Returns year-note. If it doesn't exist, it is automatically created.\n     *\n     * @method\n     * @param {string} year - e.g. \"2019\"\n     * @returns {Promise<FNote>}\n     */\n    this.getYearNote = dateNotesService.getYearNote;\n\n    /**\n     * Hoist note in the current tab. See https://github.com/zadam/trilium/wiki/Note-hoisting\n     *\n     * @method\n     * @param {string} noteId - set hoisted note. 'root' will effectively unhoist\n     * @returns {Promise<void>}\n     */\n    this.setHoistedNoteId = (noteId) => {\n        const activeNoteContext = appContext.tabManager.getActiveContext();\n\n        if (activeNoteContext) {\n            activeNoteContext.setHoistedNoteId(noteId);\n        }\n    };\n\n    /**\n     * @method\n     * @param {string} keyboardShortcut - e.g. \"ctrl+shift+a\"\n     * @param {function} handler\n     * @param {string} [namespace] - specify namespace of the handler for the cases where call for bind may be repeated.\n     *                               If a handler with this ID exists, it's replaced by the new handler.\n     * @returns {Promise<void>}\n     */\n    this.bindGlobalShortcut = shortcutService.bindGlobalShortcut;\n\n    /**\n     * Trilium runs in a backend and frontend process, when something is changed on the backend from a script,\n     * frontend will get asynchronously synchronized.\n     *\n     * This method returns a promise which resolves once all the backend -> frontend synchronization is finished.\n     * Typical use case is when a new note has been created, we should wait until it is synced into frontend and only then activate it.\n     *\n     * @method\n     * @returns {Promise<void>}\n     */\n    this.waitUntilSynced = ws.waitForMaxKnownEntityChangeId;\n\n    /**\n     * This will refresh all currently opened notes which have included note specified in the parameter\n     *\n     * @param includedNoteId - noteId of the included note\n     * @returns {Promise<void>}\n     */\n    this.refreshIncludedNote = includedNoteId => appContext.triggerEvent('refreshIncludedNote', {noteId: includedNoteId});\n\n    /**\n     * Return randomly generated string of given length. This random string generation is NOT cryptographically secure.\n     *\n     * @method\n     * @param {int} length of the string\n     * @returns {string} random string\n     */\n    this.randomString = utils.randomString;\n\n    /**\n     * @method\n     * @param {int} size in bytes\n     * @return {string} formatted string\n     */\n    this.formatSize = utils.formatSize;\n\n    /**\n     * @method\n     * @param {int} size in bytes\n     * @return {string} formatted string\n     * @deprecated - use api.formatSize()\n     */\n    this.formatNoteSize = utils.formatSize;\n\n    this.logMessages = {};\n    this.logSpacedUpdates = {};\n\n    /**\n     * Log given message to the log pane in UI\n     *\n     * @param message\n     * @returns {void}\n     */\n    this.log = message => {\n        const {noteId} = this.startNote;\n\n        message = `${utils.now()}: ${message}`;\n\n        console.log(`Script ${noteId}: ${message}`);\n\n        this.logMessages[noteId] = this.logMessages[noteId] || [];\n        this.logSpacedUpdates[noteId] = this.logSpacedUpdates[noteId] || new SpacedUpdate(() => {\n            const messages = this.logMessages[noteId];\n            this.logMessages[noteId] = [];\n\n            appContext.triggerEvent(\"apiLogMessages\", {noteId, messages});\n        }, 100);\n\n        this.logMessages[noteId].push(message);\n        this.logSpacedUpdates[noteId].scheduleUpdate();\n    };\n}\n\nexport default FrontendScriptApi;\n","import FrontendScriptApi from './frontend_script_api.js';\nimport utils from './utils.js';\nimport froca from './froca.js';\n\nasync function ScriptContext(startNoteId, allNoteIds, originEntity = null, $container = null) {\n    const modules = {};\n\n    await froca.initializedPromise;\n\n    const startNote = await froca.getNote(startNoteId);\n    const allNotes = await froca.getNotes(allNoteIds);\n\n    return {\n        modules: modules,\n        notes: utils.toObject(allNotes, note => [note.noteId, note]),\n        apis: utils.toObject(allNotes, note => [note.noteId, new FrontendScriptApi(startNote, note, originEntity, $container)]),\n        require: moduleNoteIds => {\n            return moduleName => {\n                const candidates = allNotes.filter(note => moduleNoteIds.includes(note.noteId));\n                const note = candidates.find(c => c.title === moduleName);\n\n                if (!note) {\n                    throw new Error(`Could not find module note ${moduleName}`);\n                }\n\n                return modules[note.noteId].exports;\n            }\n        }\n    };\n}\n\nexport default ScriptContext;","import server from \"./server.js\";\nimport froca from \"./froca.js\";\n\nasync function searchForNoteIds(searchString) {\n    return await server.get(`search/${encodeURIComponent(searchString)}`);\n}\n\nasync function searchForNotes(searchString) {\n    const noteIds = await searchForNoteIds(searchString);\n\n    return await froca.getNotes(noteIds);\n}\n\nexport default {\n    searchForNoteIds,\n    searchForNotes\n}\n","export default class ValidationError {\n    constructor(resp) {\n        for (const key in resp) {\n            this[key] = resp[key];\n        }\n    }\n}","import utils from './utils.js';\nimport ValidationError from \"./validation_error.js\";\n\nasync function getHeaders(headers) {\n    const appContext = (await import('../components/app_context.js')).default;\n    const activeNoteContext = appContext.tabManager ? appContext.tabManager.getActiveContext() : null;\n\n    // headers need to be lowercase because node.js automatically converts them to lower case\n    // also avoiding using underscores instead of dashes since nginx filters them out by default\n    const allHeaders = {\n        'trilium-component-id': glob.componentId,\n        'trilium-local-now-datetime': utils.localNowDateTime(),\n        'trilium-hoisted-note-id': activeNoteContext ? activeNoteContext.hoistedNoteId : null,\n        'x-csrf-token': glob.csrfToken\n    };\n\n    for (const headerName in headers) {\n        if (headers[headerName]) {\n            allHeaders[headerName] = headers[headerName];\n        }\n    }\n\n    if (utils.isElectron()) {\n        // passing it explicitly here because of the electron HTTP bypass\n        allHeaders.cookie = document.cookie;\n    }\n\n    return allHeaders;\n}\n\nasync function getWithSilentNotFound(url, componentId) {\n    return await call('GET', url, componentId, { silentNotFound: true });\n}\n\nasync function get(url, componentId) {\n    return await call('GET', url, componentId);\n}\n\nasync function post(url, data, componentId) {\n    return await call('POST', url, componentId, { data });\n}\n\nasync function put(url, data, componentId) {\n    return await call('PUT', url, componentId, { data });\n}\n\nasync function patch(url, data, componentId) {\n    return await call('PATCH', url, componentId, { data });\n}\n\nasync function remove(url, componentId) {\n    return await call('DELETE', url, componentId);\n}\n\nasync function upload(url, fileToUpload) {\n    const formData = new FormData();\n    formData.append('upload', fileToUpload);\n\n    return await $.ajax({\n        url: window.glob.baseApiUrl + url,\n        headers: await getHeaders(),\n        data: formData,\n        type: 'PUT',\n        timeout: 60 * 60 * 1000,\n        contentType: false, // NEEDED, DON'T REMOVE THIS\n        processData: false, // NEEDED, DON'T REMOVE THIS\n    });\n}\n\nlet idCounter = 1;\nconst idToRequestMap = {};\n\nlet maxKnownEntityChangeId = 0;\n\nasync function call(method, url, componentId, options = {}) {\n    let resp;\n\n    const headers = await getHeaders({\n        'trilium-component-id': componentId\n    });\n    const {data} = options;\n\n    if (utils.isElectron()) {\n        const ipc = utils.dynamicRequire('electron').ipcRenderer;\n        const requestId = idCounter++;\n\n        resp = await new Promise((resolve, reject) => {\n            idToRequestMap[requestId] = {\n                resolve,\n                reject,\n                silentNotFound: !!options.silentNotFound\n            };\n\n            ipc.send('server-request', {\n                requestId: requestId,\n                headers: headers,\n                method: method,\n                url: `/${window.glob.baseApiUrl}${url}`,\n                data: data\n            });\n        });\n    }\n    else {\n        resp = await ajax(url, method, data, headers, !!options.silentNotFound);\n    }\n\n    const maxEntityChangeIdStr = resp.headers['trilium-max-entity-change-id'];\n\n    if (maxEntityChangeIdStr && maxEntityChangeIdStr.trim()) {\n        maxKnownEntityChangeId = Math.max(maxKnownEntityChangeId, parseInt(maxEntityChangeIdStr));\n    }\n\n    return resp.body;\n}\n\nfunction ajax(url, method, data, headers, silentNotFound) {\n    return new Promise((res, rej) => {\n        const options = {\n            url: window.glob.baseApiUrl + url,\n            type: method,\n            headers: headers,\n            timeout: 60000,\n            success: (body, textStatus, jqXhr) => {\n                const respHeaders = {};\n\n                jqXhr.getAllResponseHeaders().trim().split(/[\\r\\n]+/).forEach(line => {\n                    const parts = line.split(': ');\n                    const header = parts.shift();\n                    respHeaders[header] = parts.join(': ');\n                });\n\n                res({\n                    body,\n                    headers: respHeaders\n                });\n            },\n            error: async jqXhr => {\n                if (silentNotFound && jqXhr.status === 404) {\n                    // report nothing\n                } else {\n                    await reportError(method, url, jqXhr.status, jqXhr.responseText);\n                }\n\n                rej(jqXhr.responseText);\n            }\n        };\n\n        if (data) {\n            try {\n                options.data = JSON.stringify(data);\n            } catch (e) {\n                console.log(\"Can't stringify data: \", data, \" because of error: \", e)\n            }\n            options.contentType = \"application/json\";\n        }\n\n        $.ajax(options);\n    });\n}\n\nif (utils.isElectron()) {\n    const ipc = utils.dynamicRequire('electron').ipcRenderer;\n\n    ipc.on('server-response', async (event, arg) => {\n        if (arg.statusCode >= 200 && arg.statusCode < 300) {\n            handleSuccessfulResponse(arg);\n        }\n        else {\n            if (arg.statusCode === 404 && idToRequestMap[arg.requestId]?.silentNotFound) {\n                // report nothing\n            } else {\n                await reportError(arg.method, arg.url, arg.statusCode, arg.body);\n            }\n\n            idToRequestMap[arg.requestId].reject(new Error(`Server responded with ${arg.statusCode}`));\n        }\n\n        delete idToRequestMap[arg.requestId];\n    });\n\n    function handleSuccessfulResponse(arg) {\n        if (arg.headers['Content-Type'] === 'application/json') {\n            arg.body = JSON.parse(arg.body);\n        }\n\n        if (!(arg.requestId in idToRequestMap)) {\n            // this can happen when reload happens between firing up the request and receiving the response\n            throw new Error(`Unknown requestId '${arg.requestId}'`);\n        }\n\n        idToRequestMap[arg.requestId].resolve({\n            body: arg.body,\n            headers: arg.headers\n        });\n    }\n}\n\nasync function reportError(method, url, statusCode, response) {\n    let message = response;\n\n    if (typeof response === 'string') {\n        try {\n            response = JSON.parse(response);\n            message = response.message;\n        }\n        catch (e) {}\n    }\n\n    const toastService = (await import(\"./toast.js\")).default;\n\n    if ([400, 404].includes(statusCode) && response && typeof response === 'object') {\n        toastService.showError(message);\n        throw new ValidationError({\n            requestUrl: url,\n            method,\n            statusCode,\n            ...response\n        });\n    } else {\n        const title = `${statusCode} ${method} ${url}`;\n        toastService.showErrorTitleAndMessage(title, message);\n        toastService.throwError(`${title} - ${message}`);\n    }\n}\n\nexport default {\n    get,\n    getWithSilentNotFound,\n    post,\n    put,\n    patch,\n    remove,\n    upload,\n    // don't remove, used from CKEditor image upload!\n    getHeaders,\n    getMaxKnownEntityChangeId: () => maxKnownEntityChangeId\n};\n","export default class SpacedUpdate {\n    constructor(updater, updateInterval = 1000) {\n        this.updater = updater;\n        this.lastUpdated = Date.now();\n        this.changed = false;\n        this.updateInterval = updateInterval;\n    }\n\n    scheduleUpdate() {\n        if (!this.changeForbidden) {\n            this.changed = true;\n            setTimeout(() => this.triggerUpdate());\n        }\n    }\n\n    async updateNowIfNecessary() {\n        if (this.changed) {\n            this.changed = false; // optimistic...\n\n            try {\n                await this.updater();\n            }\n            catch (e) {\n                this.changed = true;\n\n                throw e;\n            }\n        }\n    }\n\n    isAllSavedAndTriggerUpdate() {\n        const allSaved = !this.changed;\n\n        this.updateNowIfNecessary();\n\n        return allSaved;\n    }\n\n    triggerUpdate() {\n        if (!this.changed) {\n            return;\n        }\n\n        if (Date.now() - this.lastUpdated > this.updateInterval) {\n            this.updater();\n            this.lastUpdated = Date.now();\n            this.changed = false;\n        }\n        else {\n            // update isn't triggered but changes are still pending, so we need to schedule another check\n            this.scheduleUpdate();\n        }\n    }\n\n    async allowUpdateWithoutChange(callback) {\n        this.changeForbidden = true;\n\n        try {\n            await callback();\n        }\n        finally {\n            this.changeForbidden = false;\n        }\n    }\n}\n","import ws from \"./ws.js\";\nimport utils from \"./utils.js\";\n\nfunction toast(options) {\n    const $toast = $(`<div class=\"toast\" role=\"alert\" aria-live=\"assertive\" aria-atomic=\"true\">\n    <div class=\"toast-header\">\n        <strong class=\"mr-auto\"><span class=\"bx bx-${options.icon}\"></span> <span class=\"toast-title\"></span></strong>\n        <button type=\"button\" class=\"ml-2 mb-1 close\" data-dismiss=\"toast\" aria-label=\"Close\">\n            <span aria-hidden=\"true\">&times;</span>\n        </button>\n    </div>\n    <div class=\"toast-body\"></div>\n</div>`);\n\n    $toast.find('.toast-title').text(options.title);\n    $toast.find('.toast-body').text(options.message);\n\n    if (options.id) {\n        $toast.attr(\"id\", `toast-${options.id}`);\n    }\n\n    $(\"#toast-container\").append($toast);\n\n    $toast.toast({\n        delay: options.delay || 3000,\n        autohide: !!options.autohide\n    });\n\n    $toast.on('hidden.bs.toast', e => e.target.remove());\n\n    $toast.toast(\"show\");\n\n    return $toast;\n}\n\nfunction showPersistent(options) {\n    let $toast = $(`#toast-${options.id}`);\n\n    if ($toast.length > 0) {\n        $toast.find('.toast-body').html(options.message);\n    }\n    else {\n        options.autohide = false;\n\n        $toast = toast(options);\n    }\n\n    if (options.closeAfter) {\n        setTimeout(() => $toast.remove(), options.closeAfter);\n    }\n}\n\nfunction closePersistent(id) {\n    $(`#toast-${id}`).remove();\n}\n\nfunction showMessage(message, delay = 2000) {\n    console.debug(utils.now(), \"message:\", message);\n\n    toast({\n        title: \"Info\",\n        icon: \"check\",\n        message: message,\n        autohide: true,\n        delay\n    });\n}\n\nfunction showAndLogError(message, delay = 10000) {\n    showError(message, delay);\n\n    ws.logError(message);\n}\n\nfunction showError(message, delay = 10000) {\n    console.log(utils.now(), \"error: \", message);\n\n    toast({\n        title: \"Error\",\n        icon: 'alert',\n        message: message,\n        autohide: true,\n        delay\n    });\n}\n\nfunction showErrorTitleAndMessage(title, message, delay = 10000) {\n    console.log(utils.now(), \"error: \", message);\n\n    toast({\n        title: title,\n        icon: 'alert',\n        message: message,\n        autohide: true,\n        delay\n    });\n}\n\nfunction throwError(message) {\n    ws.logError(message);\n\n    throw new Error(message);\n}\n\nexport default {\n    showMessage,\n    showError,\n    showErrorTitleAndMessage,\n    showAndLogError,\n    throwError,\n    showPersistent,\n    closePersistent\n}\n","import ws from './ws.js';\nimport utils from './utils.js';\nimport froca from './froca.js';\nimport hoistedNoteService from '../services/hoisted_note.js';\nimport appContext from \"../components/app_context.js\";\n\n/**\n * @returns {string|null}\n */\nasync function resolveNotePath(notePath, hoistedNoteId = 'root') {\n    const runPath = await resolveNotePathToSegments(notePath, hoistedNoteId);\n\n    return runPath ? runPath.join(\"/\") : null;\n}\n\n/**\n * Accepts notePath which might or might not be valid and returns an existing path as close to the original\n * notePath as possible. Part of the path might not be valid because of note moving (which causes\n * path change) or other corruption, in that case, this will try to get some other valid path to the correct note.\n *\n * @returns {Promise<string[]>}\n */\nasync function resolveNotePathToSegments(notePath, hoistedNoteId = 'root', logErrors = true) {\n    utils.assertArguments(notePath);\n\n    // we might get notePath with the params suffix, remove it if present\n    notePath = notePath.split(\"?\")[0].trim();\n\n    if (notePath.length === 0) {\n        return null;\n    }\n\n    const path = notePath.split(\"/\").reverse();\n\n    if (!path.includes(\"root\")) {\n        path.push('root');\n    }\n\n    const effectivePathSegments = [];\n    let childNoteId = null;\n    let i = 0;\n\n    while (true) {\n        if (i >= path.length) {\n            break;\n        }\n\n        const parentNoteId = path[i++];\n\n        if (childNoteId !== null) {\n            const child = await froca.getNote(childNoteId, !logErrors);\n\n            if (!child) {\n                if (logErrors) {\n                    ws.logError(`Can't find note ${childNoteId}`);\n                }\n\n                return null;\n            }\n\n            child.sortParents();\n\n            const parents = child.getParentNotes();\n\n            if (!parents.length) {\n                if (logErrors) {\n                    ws.logError(`No parents found for note ${childNoteId} (${child.title}) for path ${notePath}`);\n                }\n\n                return null;\n            }\n\n            if (!parents.some(p => p.noteId === parentNoteId)) {\n                if (logErrors) {\n                    const parent = froca.getNoteFromCache(parentNoteId);\n\n                    console.debug(utils.now(), `Did not find parent ${parentNoteId} (${parent ? parent.title : 'n/a'}) \n                        for child ${childNoteId} (${child.title}), available parents: ${parents.map(p => `${p.noteId} (${p.title})`)}. \n                        You can ignore this message as it is mostly harmless.`);\n                }\n\n                const bestNotePath = child.getBestNotePath(hoistedNoteId);\n\n                if (bestNotePath) {\n                    const pathToRoot = bestNotePath.reverse().slice(1);\n\n                    for (const noteId of pathToRoot) {\n                        effectivePathSegments.push(noteId);\n                    }\n                }\n\n                break;\n            }\n        }\n\n        effectivePathSegments.push(parentNoteId);\n        childNoteId = parentNoteId;\n    }\n\n    effectivePathSegments.reverse();\n\n    if (effectivePathSegments.includes(hoistedNoteId)) {\n        return effectivePathSegments;\n    }\n    else {\n        const note = await froca.getNote(getNoteIdFromUrl(notePath));\n\n        const bestNotePath = note.getBestNotePath(hoistedNoteId);\n\n        if (!bestNotePath) {\n            throw new Error(`Did not find any path segments for '${note.toString()}', hoisted note '${hoistedNoteId}'`);\n        }\n\n        // if there isn't actually any note path with hoisted note, then return the original resolved note path\n        return bestNotePath.includes(hoistedNoteId) ? bestNotePath : effectivePathSegments;\n    }\n}\n\nws.subscribeToMessages(message => {\n   if (message.type === 'openNote') {\n       appContext.tabManager.activateOrOpenNote(message.noteId);\n\n       if (utils.isElectron()) {\n           const currentWindow = utils.dynamicRequire('@electron/remote').getCurrentWindow();\n\n           currentWindow.show();\n       }\n   }\n});\n\nfunction getParentProtectedStatus(node) {\n    return hoistedNoteService.isHoistedNode(node) ? false : node.getParent().data.isProtected;\n}\n\nfunction getNoteIdFromUrl(urlOrNotePath) {\n    if (!urlOrNotePath) {\n        return null;\n    }\n\n    const [notePath] = urlOrNotePath.split(\"?\");\n    const segments = notePath.split(\"/\");\n\n    return segments[segments.length - 1];\n}\n\nasync function getBranchIdFromUrl(urlOrNotePath) {\n    const {noteId, parentNoteId} = getNoteIdAndParentIdFromUrl(urlOrNotePath);\n\n    return await froca.getBranchId(parentNoteId, noteId);\n}\n\nfunction getNoteIdAndParentIdFromUrl(urlOrNotePath) {\n    if (!urlOrNotePath) {\n        return {};\n    }\n\n    const [notePath] = urlOrNotePath.split(\"?\");\n\n    if (notePath === 'root') {\n        return {\n            noteId: 'root',\n            parentNoteId: 'none'\n        };\n    }\n\n    let parentNoteId = 'root';\n    let noteId = '';\n\n    if (notePath) {\n        const segments = notePath.split(\"/\");\n\n        noteId = segments[segments.length - 1];\n\n        if (segments.length > 1) {\n            parentNoteId = segments[segments.length - 2];\n        }\n    }\n\n    return {\n        parentNoteId,\n        noteId\n    };\n}\n\nfunction getNotePath(node) {\n    if (!node) {\n        logError(\"Node is null\");\n        return \"\";\n    }\n\n    const path = [];\n\n    while (node) {\n        if (node.data.noteId) {\n            path.push(node.data.noteId);\n        }\n\n        node = node.getParent();\n    }\n\n    return path.reverse().join(\"/\");\n}\n\nasync function getNoteTitle(noteId, parentNoteId = null) {\n    utils.assertArguments(noteId);\n\n    const note = await froca.getNote(noteId);\n    if (!note) {\n        return \"[not found]\";\n    }\n\n    let {title} = note;\n\n    if (parentNoteId !== null) {\n        const branchId = note.parentToBranch[parentNoteId];\n\n        if (branchId) {\n            const branch = froca.getBranch(branchId);\n\n            if (branch?.prefix) {\n                title = `${branch.prefix} - ${title}`;\n            }\n        }\n    }\n\n    return title;\n}\n\nasync function getNotePathTitleComponents(notePath) {\n    const titleComponents = [];\n\n    if (notePath.startsWith('root/')) {\n        notePath = notePath.substr(5);\n    }\n\n    // special case when we want just root's title\n    if (notePath === 'root') {\n        titleComponents.push(await getNoteTitle(notePath));\n    } else {\n        let parentNoteId = 'root';\n\n        for (const noteId of notePath.split('/')) {\n            titleComponents.push(await getNoteTitle(noteId, parentNoteId));\n\n            parentNoteId = noteId;\n        }\n    }\n\n    return titleComponents;\n}\n\nasync function getNotePathTitle(notePath) {\n    utils.assertArguments(notePath);\n\n    const titlePath = await getNotePathTitleComponents(notePath);\n\n    return titlePath.join(' / ');\n}\n\nasync function getNoteTitleWithPathAsSuffix(notePath) {\n    utils.assertArguments(notePath);\n\n    const titleComponents = await getNotePathTitleComponents(notePath);\n\n    if (!titleComponents || titleComponents.length === 0) {\n        return \"\";\n    }\n\n    const title = titleComponents[titleComponents.length - 1];\n    const path = titleComponents.slice(0, titleComponents.length - 1);\n\n    const $titleWithPath = $('<span class=\"note-title-with-path\">')\n        .append($('<span class=\"note-title\">').text(title));\n\n    if (path.length > 0) {\n        $titleWithPath\n            .append($('<span class=\"note-path\">').text(` (${path.join(' / ')})`));\n    }\n\n    return $titleWithPath;\n}\n\nfunction isNotePathInHiddenSubtree(notePath) {\n    return notePath?.includes(\"root/_hidden\");\n}\n\nexport default {\n    resolveNotePath,\n    resolveNotePathToSegments,\n    getParentProtectedStatus,\n    getNotePath,\n    getNoteIdFromUrl,\n    getNoteIdAndParentIdFromUrl,\n    getBranchIdFromUrl,\n    getNoteTitle,\n    getNotePathTitle,\n    getNoteTitleWithPathAsSuffix,\n    isNotePathInHiddenSubtree\n};\n","export default class LoadResults {\n    constructor(entityChanges) {\n        this.entities = {};\n\n        for (const {entityId, entityName, entity} of entityChanges) {\n            if (entity) {\n                this.entities[entityName] = this.entities[entityName] || [];\n                this.entities[entityName][entityId] = entity;\n            }\n        }\n\n        this.noteIdToComponentId = {};\n        this.componentIdToNoteIds = {};\n\n        this.branchRows = [];\n\n        this.attributeRows = [];\n\n        this.noteReorderings = [];\n\n        this.revisionRows = [];\n\n        this.contentNoteIdToComponentId = [];\n\n        this.optionNames = [];\n\n        this.attachmentRows = [];\n    }\n\n    getEntityRow(entityName, entityId) {\n        return this.entities[entityName]?.[entityId];\n    }\n\n    addNote(noteId, componentId) {\n        this.noteIdToComponentId[noteId] = this.noteIdToComponentId[noteId] || [];\n\n        if (!this.noteIdToComponentId[noteId].includes(componentId)) {\n            this.noteIdToComponentId[noteId].push(componentId);\n        }\n\n        this.componentIdToNoteIds[componentId] = this.componentIdToNoteIds[componentId] || [];\n\n        if (!this.componentIdToNoteIds[componentId]) {\n            this.componentIdToNoteIds[componentId].push(noteId);\n        }\n    }\n\n    addBranch(branchId, componentId) {\n        this.branchRows.push({branchId, componentId});\n    }\n\n    getBranchRows() {\n        return this.branchRows\n            .map(row => this.getEntityRow(\"branches\", row.branchId))\n            .filter(branch => !!branch);\n    }\n\n    addNoteReordering(parentNoteId, componentId) {\n        this.noteReorderings.push(parentNoteId);\n    }\n\n    getNoteReorderings() {\n        return this.noteReorderings;\n    }\n\n    addAttribute(attributeId, componentId) {\n        this.attributeRows.push({attributeId, componentId});\n    }\n\n    getAttributeRows(componentId = 'none') {\n        return this.attributeRows\n            .filter(row => row.componentId !== componentId)\n            .map(row => this.getEntityRow(\"attributes\", row.attributeId))\n            .filter(attr => !!attr);\n    }\n\n    addRevision(revisionId, noteId, componentId) {\n        this.revisionRows.push({revisionId, noteId, componentId});\n    }\n\n    hasRevisionForNote(noteId) {\n        return !!this.revisionRows.find(row => row.noteId === noteId);\n    }\n\n    getNoteIds() {\n        return Object.keys(this.noteIdToComponentId);\n    }\n\n    isNoteReloaded(noteId, componentId = null) {\n        if (!noteId) {\n            return false;\n        }\n\n        const componentIds = this.noteIdToComponentId[noteId];\n        return componentIds && componentIds.find(sId => sId !== componentId) !== undefined;\n    }\n\n    addNoteContent(noteId, componentId) {\n        this.contentNoteIdToComponentId.push({noteId, componentId});\n    }\n\n    isNoteContentReloaded(noteId, componentId) {\n        if (!noteId) {\n            return false;\n        }\n\n        return this.contentNoteIdToComponentId.find(l => l.noteId === noteId && l.componentId !== componentId);\n    }\n\n    addOption(name) {\n        this.optionNames.push(name);\n    }\n\n    isOptionReloaded(name) {\n        return this.optionNames.includes(name);\n    }\n\n    getOptionNames() {\n        return this.optionNames;\n    }\n\n    addAttachmentRow(attachment) {\n        this.attachmentRows.push(attachment);\n    }\n\n    getAttachmentRows() {\n        return this.attachmentRows;\n    }\n\n    /**\n     * @returns {boolean} true if there are changes which could affect the attributes (including inherited ones)\n     *          notably changes in note itself should not have any effect on attributes\n     */\n    hasAttributeRelatedChanges() {\n        return this.branchRows.length > 0\n            || this.attributeRows.length > 0;\n    }\n\n    isEmpty() {\n        return Object.keys(this.noteIdToComponentId).length === 0\n            && this.branchRows.length === 0\n            && this.attributeRows.length === 0\n            && this.noteReorderings.length === 0\n            && this.revisionRows.length === 0\n            && this.contentNoteIdToComponentId.length === 0\n            && this.optionNames.length === 0\n            && this.attachmentRows.length === 0;\n    }\n\n    isEmptyForTree() {\n        return Object.keys(this.noteIdToComponentId).length === 0\n            && this.branchRows.length === 0\n            && this.attributeRows.length === 0\n            && this.noteReorderings.length === 0;\n    }\n}\n","import LoadResults from \"./load_results.js\";\nimport froca from \"./froca.js\";\nimport utils from \"./utils.js\";\nimport options from \"./options.js\";\nimport noteAttributeCache from \"./note_attribute_cache.js\";\nimport FBranch from \"../entities/fbranch.js\";\nimport FAttribute from \"../entities/fattribute.js\";\nimport FAttachment from \"../entities/fattachment.js\";\n\nasync function processEntityChanges(entityChanges) {\n    const loadResults = new LoadResults(entityChanges);\n\n    for (const ec of entityChanges) {\n        try {\n            if (ec.entityName === 'notes') {\n                processNoteChange(loadResults, ec);\n            } else if (ec.entityName === 'branches') {\n                await processBranchChange(loadResults, ec);\n            } else if (ec.entityName === 'attributes') {\n                processAttributeChange(loadResults, ec);\n            } else if (ec.entityName === 'note_reordering') {\n                processNoteReordering(loadResults, ec);\n            } else if (ec.entityName === 'revisions') {\n                loadResults.addRevision(ec.entityId, ec.noteId, ec.componentId);\n            } else if (ec.entityName === 'options') {\n                if (ec.entity.name === 'openNoteContexts') {\n                    continue; // only noise\n                }\n\n                options.set(ec.entity.name, ec.entity.value);\n\n                loadResults.addOption(ec.entity.name);\n            } else if (ec.entityName === 'attachments') {\n                processAttachment(loadResults, ec);\n            } else if (ec.entityName === 'blobs' || ec.entityName === 'etapi_tokens') {\n                // NOOP\n            }\n            else {\n                throw new Error(`Unknown entityName '${ec.entityName}'`);\n            }\n        }\n        catch (e) {\n            throw new Error(`Can't process entity ${JSON.stringify(ec)} with error ${e.message} ${e.stack}`);\n        }\n    }\n\n    // froca is supposed to contain all notes currently being visible to the users in the tree / otherwise being processed\n    // and their complete \"ancestor relationship\", so it's always possible to go up in the hierarchy towards the root.\n    // To this we count: standard parent-child relationships and template/inherit relations (attribute inheritance follows them).\n    // Here we watch for changes which might violate this principle - e.g., an introduction of a new \"inherit\" relation might\n    // mean we need to load the target of the relation (and then perhaps transitively the whole note path of this target).\n    const missingNoteIds = [];\n\n    for (const {entityName, entity} of entityChanges) {\n        if (!entity) { // if erased\n            continue;\n        }\n\n        if (entityName === 'branches' && !(entity.parentNoteId in froca.notes)) {\n            missingNoteIds.push(entity.parentNoteId);\n        }\n        else if (entityName === 'attributes'\n            && entity.type === 'relation'\n            && (entity.name === 'template' || entity.name === 'inherit')\n            && !(entity.value in froca.notes)) {\n\n            missingNoteIds.push(entity.value);\n        }\n    }\n\n    if (missingNoteIds.length > 0) {\n        await froca.reloadNotes(missingNoteIds);\n    }\n\n    if (!loadResults.isEmpty()) {\n        if (loadResults.hasAttributeRelatedChanges()) {\n            noteAttributeCache.invalidate();\n        }\n\n        const appContext = (await import(\"../components/app_context.js\")).default;\n        await appContext.triggerEvent('entitiesReloaded', {loadResults});\n    }\n}\n\nfunction processNoteChange(loadResults, ec) {\n    const note = froca.notes[ec.entityId];\n\n    if (!note) {\n        // if this note has not been requested before then it's not part of froca's cached subset, and\n        // we're not interested in it\n        return;\n    }\n\n    loadResults.addNote(ec.entityId, ec.componentId);\n\n    if (ec.isErased && ec.entityId in froca.notes) {\n        utils.reloadFrontendApp(`${ec.entityName} '${ec.entityId}' is erased, need to do complete reload.`);\n        return;\n    }\n\n    if (ec.isErased || ec.entity?.isDeleted) {\n        delete froca.notes[ec.entityId];\n    }\n    else {\n        if (note.blobId !== ec.entity.blobId) {\n            for (const key of Object.keys(froca.blobPromises)) {\n                if (key.includes(note.noteId)) {\n                    delete froca.blobPromises[key];\n                }\n            }\n\n            loadResults.addNoteContent(note.noteId, ec.componentId);\n        }\n\n        note.update(ec.entity);\n    }\n}\n\nasync function processBranchChange(loadResults, ec) {\n    if (ec.isErased && ec.entityId in froca.branches) {\n        utils.reloadFrontendApp(`${ec.entityName} '${ec.entityId}' is erased, need to do complete reload.`);\n        return;\n    }\n\n    let branch = froca.branches[ec.entityId];\n\n    if (ec.isErased || ec.entity?.isDeleted) {\n        if (branch) {\n            const childNote = froca.notes[branch.noteId];\n            const parentNote = froca.notes[branch.parentNoteId];\n\n            if (childNote) {\n                childNote.parents = childNote.parents.filter(parentNoteId => parentNoteId !== branch.parentNoteId);\n                delete childNote.parentToBranch[branch.parentNoteId];\n            }\n\n            if (parentNote) {\n                parentNote.children = parentNote.children.filter(childNoteId => childNoteId !== branch.noteId);\n                delete parentNote.childToBranch[branch.noteId];\n            }\n\n            loadResults.addBranch(ec.entityId, ec.componentId);\n\n            delete froca.branches[ec.entityId];\n        }\n\n        return;\n    }\n\n    loadResults.addBranch(ec.entityId, ec.componentId);\n\n    const childNote = froca.notes[ec.entity.noteId];\n    let parentNote = froca.notes[ec.entity.parentNoteId];\n\n    if (childNote && !childNote.isRoot() && !parentNote) {\n        // a branch cannot exist without the parent\n        // a note loaded into froca has to also contain all its ancestors,\n        // this problem happened, e.g., in sharing where _share was hidden and thus not loaded\n        // sharing meant cloning into _share, which crashed because _share was not loaded\n        parentNote = await froca.getNote(ec.entity.parentNoteId);\n    }\n\n    if (branch) {\n        branch.update(ec.entity);\n    }\n    else if (childNote || parentNote) {\n        froca.branches[ec.entityId] = branch = new FBranch(froca, ec.entity);\n    }\n\n    if (childNote) {\n        childNote.addParent(branch.parentNoteId, branch.branchId);\n    }\n\n    if (parentNote) {\n        parentNote.addChild(branch.noteId, branch.branchId);\n    }\n}\n\nfunction processNoteReordering(loadResults, ec) {\n    const parentNoteIdsToSort = new Set();\n\n    for (const branchId in ec.positions) {\n        const branch = froca.branches[branchId];\n\n        if (branch) {\n            branch.notePosition = ec.positions[branchId];\n\n            parentNoteIdsToSort.add(branch.parentNoteId);\n        }\n    }\n\n    for (const parentNoteId of parentNoteIdsToSort) {\n        const parentNote = froca.notes[parentNoteId];\n\n        if (parentNote) {\n            parentNote.sortChildren();\n        }\n    }\n\n    loadResults.addNoteReordering(ec.entityId, ec.componentId);\n}\n\nfunction processAttributeChange(loadResults, ec) {\n    let attribute = froca.attributes[ec.entityId];\n\n    if (ec.isErased && ec.entityId in froca.attributes) {\n        utils.reloadFrontendApp(`${ec.entityName} '${ec.entityId}' is erased, need to do complete reload.`);\n        return;\n    }\n\n    if (ec.isErased || ec.entity?.isDeleted) {\n        if (attribute) {\n            const sourceNote = froca.notes[attribute.noteId];\n            const targetNote = attribute.type === 'relation' && froca.notes[attribute.value];\n\n            if (sourceNote) {\n                sourceNote.attributes = sourceNote.attributes.filter(attributeId => attributeId !== attribute.attributeId);\n            }\n\n            if (targetNote) {\n                targetNote.targetRelations = targetNote.targetRelations.filter(attributeId => attributeId !== attribute.attributeId);\n            }\n\n            loadResults.addAttribute(ec.entityId, ec.componentId);\n\n            delete froca.attributes[ec.entityId];\n        }\n\n        return;\n    }\n\n    loadResults.addAttribute(ec.entityId, ec.componentId);\n\n    const sourceNote = froca.notes[ec.entity.noteId];\n    const targetNote = ec.entity.type === 'relation' && froca.notes[ec.entity.value];\n\n    if (attribute) {\n        attribute.update(ec.entity);\n    } else if (sourceNote || targetNote) {\n        attribute = new FAttribute(froca, ec.entity);\n\n        froca.attributes[attribute.attributeId] = attribute;\n\n        if (sourceNote && !sourceNote.attributes.includes(attribute.attributeId)) {\n            sourceNote.attributes.push(attribute.attributeId);\n        }\n\n        if (targetNote && !targetNote.targetRelations.includes(attribute.attributeId)) {\n            targetNote.targetRelations.push(attribute.attributeId);\n        }\n    }\n}\n\nfunction processAttachment(loadResults, ec) {\n    if (ec.isErased && ec.entityId in froca.attachments) {\n        utils.reloadFrontendApp(`${ec.entityName} '${ec.entityId}' is erased, need to do complete reload.`);\n        return;\n    }\n\n    const attachment = froca.attachments[ec.entityId];\n\n    if (ec.isErased || ec.entity?.isDeleted) {\n        if (attachment) {\n            const note = attachment.getNote();\n\n            if (note && note.attachments) {\n                note.attachments = note.attachments.filter(att => att.attachmentId !== attachment.attachmentId);\n            }\n\n            loadResults.addAttachmentRow(ec.entity);\n\n            delete froca.attachments[ec.entityId];\n        }\n\n        return;\n    }\n\n    if (attachment) {\n        attachment.update(ec.entity);\n    } else {\n        const note = froca.notes[ec.entity.ownerId];\n\n        if (note?.attachments) {\n            note.attachments.push(new FAttachment(froca, ec.entity));\n        }\n    }\n\n    loadResults.addAttachmentRow(ec.entity);\n}\n\nexport default {\n    processEntityChanges\n}\n","import utils from './utils.js';\nimport toastService from \"./toast.js\";\nimport server from \"./server.js\";\nimport options from \"./options.js\";\nimport frocaUpdater from \"./froca_updater.js\";\nimport appContext from \"../components/app_context.js\";\n\nconst messageHandlers = [];\n\nlet ws;\nlet lastAcceptedEntityChangeId = window.glob.maxEntityChangeIdAtLoad;\nlet lastAcceptedEntityChangeSyncId = window.glob.maxEntityChangeSyncIdAtLoad;\nlet lastProcessedEntityChangeId = window.glob.maxEntityChangeIdAtLoad;\nlet lastPingTs;\nlet frontendUpdateDataQueue = [];\n\nfunction logError(message) {\n    console.error(utils.now(), message); // needs to be separate from .trace()\n\n    if (ws && ws.readyState === 1) {\n        ws.send(JSON.stringify({\n            type: 'log-error',\n            error: message,\n            stack: new Error().stack\n        }));\n    }\n}\n\nfunction logInfo(message) {\n    console.log(utils.now(), message);\n\n    if (ws && ws.readyState === 1) {\n        ws.send(JSON.stringify({\n            type: 'log-info',\n            info: message\n        }));\n    }\n}\n\nwindow.logError = logError;\nwindow.logInfo = logInfo;\n\nfunction subscribeToMessages(messageHandler) {\n    messageHandlers.push(messageHandler);\n}\n\n// used to serialize frontend update operations\nlet consumeQueuePromise = null;\n\n// to make sure each change event is processed only once. Not clear if this is still necessary\nconst processedEntityChangeIds = new Set();\n\nfunction logRows(entityChanges) {\n    const filteredRows = entityChanges.filter(row =>\n        !processedEntityChangeIds.has(row.id)\n        && (row.entityName !== 'options' || row.entityId !== 'openNoteContexts'));\n\n    if (filteredRows.length > 0) {\n        console.debug(utils.now(), \"Frontend update data: \", filteredRows);\n    }\n}\n\nasync function executeFrontendUpdate(entityChanges) {\n    lastPingTs = Date.now();\n\n    if (entityChanges.length > 0) {\n        logRows(entityChanges);\n\n        frontendUpdateDataQueue.push(...entityChanges);\n\n        // we set lastAcceptedEntityChangeId even before frontend update processing and send ping so that backend can start sending more updates\n\n        for (const entityChange of entityChanges) {\n            lastAcceptedEntityChangeId = Math.max(lastAcceptedEntityChangeId, entityChange.id);\n\n            if (entityChange.isSynced) {\n                lastAcceptedEntityChangeSyncId = Math.max(lastAcceptedEntityChangeSyncId, entityChange.id);\n            }\n        }\n\n        sendPing();\n\n        // first wait for all the preceding consumers to finish\n        while (consumeQueuePromise) {\n            await consumeQueuePromise;\n        }\n\n        try {\n            // it's my turn, so start it up\n            consumeQueuePromise = consumeFrontendUpdateData();\n\n            await consumeQueuePromise;\n        } finally {\n            // finish and set to null to signal somebody else can pick it up\n            consumeQueuePromise = null;\n        }\n    }\n}\n\nasync function handleMessage(event) {\n    const message = JSON.parse(event.data);\n\n    for (const messageHandler of messageHandlers) {\n        messageHandler(message);\n    }\n\n    if (message.type === 'ping') {\n        lastPingTs = Date.now();\n    }\n    else if (message.type === 'reload-frontend') {\n        utils.reloadFrontendApp(\"received request from backend to reload frontend\");\n    }\n    else if (message.type === 'frontend-update') {\n        await executeFrontendUpdate(message.data.entityChanges);\n    }\n    else if (message.type === 'sync-hash-check-failed') {\n        toastService.showError(\"Sync check failed!\", 60000);\n    }\n    else if (message.type === 'consistency-checks-failed') {\n        toastService.showError(\"Consistency checks failed! See logs for details.\", 50 * 60000);\n    }\n    else if (message.type === 'api-log-messages') {\n        appContext.triggerEvent(\"apiLogMessages\", {noteId: message.noteId, messages: message.messages});\n    }\n    else if (message.type === 'toast') {\n        toastService.showMessage(message.message);\n    }\n    else if (message.type === 'execute-script') {\n        const bundleService = (await import(\"../services/bundle.js\")).default;\n        const froca = (await import(\"../services/froca.js\")).default;\n        const originEntity = message.originEntityId ? await froca.getNote(message.originEntityId) : null;\n\n        bundleService.getAndExecuteBundle(message.currentNoteId, originEntity, message.script, message.params);\n    }\n}\n\nlet entityChangeIdReachedListeners = [];\n\nfunction waitForEntityChangeId(desiredEntityChangeId) {\n    if (desiredEntityChangeId <= lastProcessedEntityChangeId) {\n        return Promise.resolve();\n    }\n\n    console.debug(`Waiting for ${desiredEntityChangeId}, last processed is ${lastProcessedEntityChangeId}, last accepted ${lastAcceptedEntityChangeId}`);\n\n    return new Promise((res, rej) => {\n        entityChangeIdReachedListeners.push({\n            desiredEntityChangeId: desiredEntityChangeId,\n            resolvePromise: res,\n            start: Date.now()\n        })\n    });\n}\n\nfunction waitForMaxKnownEntityChangeId() {\n    return waitForEntityChangeId(server.getMaxKnownEntityChangeId());\n}\n\nfunction checkEntityChangeIdListeners() {\n    entityChangeIdReachedListeners\n        .filter(l => l.desiredEntityChangeId <= lastProcessedEntityChangeId)\n        .forEach(l => l.resolvePromise());\n\n    entityChangeIdReachedListeners = entityChangeIdReachedListeners\n        .filter(l => l.desiredEntityChangeId > lastProcessedEntityChangeId);\n\n    entityChangeIdReachedListeners.filter(l => Date.now() > l.start - 60000)\n        .forEach(l => console.log(`Waiting for entityChangeId ${l.desiredEntityChangeId} while last processed is ${lastProcessedEntityChangeId} (last accepted ${lastAcceptedEntityChangeId}) for ${Math.floor((Date.now() - l.start) / 1000)}s`));\n}\n\nasync function consumeFrontendUpdateData() {\n    if (frontendUpdateDataQueue.length > 0) {\n        const allEntityChanges = frontendUpdateDataQueue;\n        frontendUpdateDataQueue = [];\n\n        const nonProcessedEntityChanges = allEntityChanges.filter(ec => !processedEntityChangeIds.has(ec.id));\n\n        try {\n            await utils.timeLimit(frocaUpdater.processEntityChanges(nonProcessedEntityChanges), 30000);\n        }\n        catch (e) {\n            logError(`Encountered error ${e.message}: ${e.stack}, reloading frontend.`);\n\n            if (!glob.isDev && !options.is('debugModeEnabled')) {\n                // if there's an error in updating the frontend, then the easy option to recover is to reload the frontend completely\n\n                utils.reloadFrontendApp();\n            }\n            else {\n                console.log(\"nonProcessedEntityChanges causing the timeout\", nonProcessedEntityChanges);\n\n                toastService.showError(`Encountered error \"${e.message}\", check out the console.`);\n            }\n        }\n\n        for (const entityChange of nonProcessedEntityChanges) {\n            processedEntityChangeIds.add(entityChange.id);\n\n            lastProcessedEntityChangeId = Math.max(lastProcessedEntityChangeId, entityChange.id);\n        }\n    }\n\n    checkEntityChangeIdListeners();\n}\n\nfunction connectWebSocket() {\n    const loc = window.location;\n    const webSocketUri = `${loc.protocol === \"https:\" ? \"wss:\" : \"ws:\"}//${loc.host}${loc.pathname}`;\n\n    // use wss for secure messaging\n    const ws = new WebSocket(webSocketUri);\n    ws.onopen = () => console.debug(utils.now(), `Connected to server ${webSocketUri} with WebSocket`);\n    ws.onmessage = handleMessage;\n    // we're not handling ws.onclose here because reconnection is done in sendPing()\n\n    return ws;\n}\n\nasync function sendPing() {\n    if (Date.now() - lastPingTs > 30000) {\n        console.log(utils.now(), \"Lost websocket connection to the backend. If you keep having this issue repeatedly, you might want to check your reverse proxy (nginx, apache) configuration and allow/unblock WebSocket.\");\n    }\n\n    if (ws.readyState === ws.OPEN) {\n        ws.send(JSON.stringify({\n            type: 'ping',\n            lastEntityChangeId: lastAcceptedEntityChangeId\n        }));\n    }\n    else if (ws.readyState === ws.CLOSED || ws.readyState === ws.CLOSING) {\n        console.log(utils.now(), \"WS closed or closing, trying to reconnect\");\n\n        ws = connectWebSocket();\n    }\n}\n\nsetTimeout(() => {\n    ws = connectWebSocket();\n\n    lastPingTs = Date.now();\n\n    setInterval(sendPing, 1000);\n}, 0);\n\nexport default {\n    logError,\n    subscribeToMessages,\n    waitForMaxKnownEntityChangeId,\n    getMaxKnownEntityChangeSyncId: () => lastAcceptedEntityChangeSyncId\n};\n","import Component from \"../components/component.js\";\n\n\n/**\n * This is the base widget for all other widgets.\n *\n * For information on using widgets, see the tutorial {@tutorial widget_basics}.\n */\nclass BasicWidget extends Component {\n    constructor() {\n        super();\n\n        this.attrs = {\n            style: ''\n        };\n        this.classes = [];\n\n        this.children = [];\n        this.childPositionCounter = 10;\n    }\n\n    child(...components) {\n        if (!components) {\n            return this;\n        }\n\n        super.child(...components);\n\n        for (const component of components) {\n            if (component.position === undefined) {\n                component.position = this.childPositionCounter;\n                this.childPositionCounter += 10;\n            }\n        }\n\n        this.children.sort((a, b) => a.position - b.position);\n\n        return this;\n    }\n\n    id(id) {\n        this.attrs.id = id;\n        return this;\n    }\n\n    class(className) {\n        this.classes.push(className);\n        return this;\n    }\n\n    css(name, value) {\n        this.attrs.style += `${name}: ${value};`;\n        return this;\n    }\n\n    contentSized() {\n        this.css(\"contain\", \"none\");\n\n        return this;\n    }\n\n    collapsible() {\n        this.css('min-height', '0');\n        this.css('min-width', '0');\n        return this;\n    }\n\n    filling() {\n        this.css('flex-grow', '1');\n        return this;\n    }\n\n    /**\n     * Accepts a string of CSS to add with the widget.\n     * @param {string} block\n     * @returns {this} for chaining\n     */\n    cssBlock(block) {\n        this.cssEl = block;\n        return this;\n    }\n\n    render() {\n        this.doRender();\n\n        this.$widget.attr('data-component-id', this.componentId);\n        this.$widget\n            .addClass('component')\n            .prop('component', this);\n\n        if (!this.isEnabled()) {\n            this.toggleInt(false);\n        }\n\n        if (this.cssEl) {\n            const css = this.cssEl.trim().startsWith('<style>') ? this.cssEl : `<style>${this.cssEl}</style>`;\n\n            this.$widget.append(css);\n        }\n\n        for (const key in this.attrs) {\n            if (key === 'style') {\n                if (this.attrs[key]) {\n                    let style = this.$widget.attr('style');\n                    style = style ? `${style}; ${this.attrs[key]}` : this.attrs[key];\n\n                    this.$widget.attr(key, style);\n                }\n            }\n            else {\n                this.$widget.attr(key, this.attrs[key]);\n            }\n        }\n\n        for (const className of this.classes) {\n            this.$widget.addClass(className);\n        }\n\n        return this.$widget;\n    }\n\n    isEnabled() {\n        return true;\n    }\n\n    /**\n     * Method used for rendering the widget.\n     *\n     * Your class should override this method.\n     * The method is expected to create a this.$widget containing jQuery object\n     */\n    doRender() {}\n\n    toggleInt(show) {\n        this.$widget.toggleClass('hidden-int', !show);\n    }\n\n    isHiddenInt() {\n        return this.$widget.hasClass('hidden-int');\n    }\n\n    toggleExt(show) {\n        this.$widget.toggleClass('hidden-ext', !show);\n    }\n\n    isHiddenExt() {\n        return this.$widget.hasClass('hidden-ext');\n    }\n\n    canBeShown() {\n        return !this.isHiddenInt() && !this.isHiddenExt();\n    }\n\n    isVisible() {\n        return this.$widget.is(\":visible\");\n    }\n\n    getPosition() {\n        return this.position;\n    }\n\n    remove() {\n        if (this.$widget) {\n            this.$widget.remove();\n        }\n    }\n\n    getClosestNtxId() {\n        if (this.$widget) {\n            return this.$widget.closest(\"[data-ntx-id]\").attr(\"data-ntx-id\");\n        }\n        else {\n            return null;\n        }\n    }\n\n    cleanup() {}\n}\n\nexport default BasicWidget;\n","import BasicWidget from \"./basic_widget.js\";\nimport appContext from \"../components/app_context.js\";\n\n/**\n * This widget allows for changing and updating depending on the active note.\n * @extends {BasicWidget}\n */\nclass NoteContextAwareWidget extends BasicWidget {\n    isNoteContext(ntxId) {\n        if (Array.isArray(ntxId)) {\n            return this.noteContext && ntxId.includes(this.noteContext.ntxId);\n        }\n        else {\n            return this.noteContext && this.noteContext.ntxId === ntxId;\n        }\n    }\n\n    isActiveNoteContext() {\n        return appContext.tabManager.getActiveContext() === this.noteContext;\n    }\n\n    isNote(noteId) {\n        return this.noteId === noteId;\n    }\n\n    /** @returns {FNote|undefined} */\n    get note() {\n        return this.noteContext?.note;\n    }\n\n    /** @returns {string|undefined} */\n    get noteId() {\n        return this.note?.noteId;\n    }\n\n    /** @returns {string|undefined} */\n    get notePath() {\n        return this.noteContext?.notePath;\n    }\n\n    /** @returns {string} */\n    get hoistedNoteId() {\n        return this.noteContext?.hoistedNoteId;\n    }\n\n    get ntxId() {\n        return this.noteContext?.ntxId;\n    }\n\n    /**\n     * @returns {boolean} true when an active note exists\n     */\n    isEnabled() {\n        return !!this.note;\n    }\n\n    async refresh() {\n        if (this.isEnabled()) {\n            this.toggleInt(true);\n            await this.refreshWithNote(this.note);\n        }\n        else {\n            this.toggleInt(false);\n        }\n    }\n\n    /**\n     * Override this method to be able to refresh your\n     * widget with each note.\n     * @param {FNote} note\n     * @returns {Promise<void>}\n     */\n    async refreshWithNote(note) {}\n\n    async noteSwitchedEvent({noteContext, notePath}) {\n        // if notePath does not match, then the noteContext has been switched to another note in the meantime\n        if (noteContext.notePath === notePath) {\n            await this.noteSwitched();\n        }\n    }\n\n    async noteSwitched() {\n        await this.refresh();\n    }\n\n    async activeContextChangedEvent({noteContext}) {\n        this.noteContext = noteContext;\n\n        await this.activeContextChanged();\n    }\n\n    async activeContextChanged() {\n        await this.refresh();\n    }\n\n    // when note is both switched and activated, this should not produce a double refresh\n    async noteSwitchedAndActivatedEvent({noteContext, notePath}) {\n        this.noteContext = noteContext;\n\n        // if notePath does not match, then the noteContext has been switched to another note in the meantime\n        if (this.notePath === notePath) {\n            await this.refresh();\n        }\n    }\n\n    setNoteContextEvent({noteContext}) {\n        /** @var {NoteContext} */\n        this.noteContext = noteContext;\n    }\n\n    async noteTypeMimeChangedEvent({noteId}) {\n        if (this.isNote(noteId)) {\n            await this.refresh();\n        }\n    }\n\n    async frocaReloadedEvent() {\n        await this.refresh();\n    }\n}\n\nexport default NoteContextAwareWidget;\n","import NoteContextAwareWidget from \"./note_context_aware_widget.js\";\n\nconst WIDGET_TPL = `\n<div class=\"card widget\">\n    <div class=\"card-header\">\n        <div class=\"card-header-title\"></div>\n        <div class=\"card-header-buttons\"></div>\n    </div>\n\n    <div id=\"[to be set]\" class=\"body-wrapper\">\n        <div class=\"card-body\"></div>\n    </div>\n</div>`;\n\n/**\n * This widget manages rendering panels in the right-hand pane.\n * @extends {NoteContextAwareWidget}\n */\nclass RightPanelWidget extends NoteContextAwareWidget {\n    /** Title to show in the panel. */\n    get widgetTitle() { return \"Untitled widget\"; }\n\n    get widgetButtons() { return []; }\n\n    get help() { return {}; }\n\n    constructor() {\n        super();\n\n        this.child(...this.widgetButtons);\n    }\n\n    /**\n     * Do not override this method unless you know what you're doing.\n     * Do not override this method unless you know what you're doing.\n     */\n    doRender() {\n        this.$widget = $(WIDGET_TPL);\n        this.contentSized();\n        this.$widget.find('[data-target]').attr('data-target', `#${this.componentId}`);\n\n        this.$bodyWrapper = this.$widget.find('.body-wrapper');\n        this.$bodyWrapper.attr('id', this.componentId); // for toggle to work we need id\n\n        this.$body = this.$bodyWrapper.find('.card-body');\n\n        this.$title = this.$widget.find('.card-header .card-header-title');\n        this.$title.text(this.widgetTitle);\n\n        this.$buttons = this.$widget.find('.card-header .card-header-buttons');\n        this.$buttons.empty();\n\n        for (const buttonWidget of this.children) {\n            this.$buttons.append(buttonWidget.render());\n        }\n\n        this.initialized = this.doRenderBody();\n    }\n\n    /**\n     * Method used for rendering the body of the widget (via existing this.$body)\n     *\n     * Your class should override this method.\n     * @returns {Promise|undefined} if widget needs async operation to initialize, it can return a Promise\n     */\n    async doRenderBody() {}\n}\n\nexport default RightPanelWidget;\n"],"names":["RootCommandExecutor","editReadOnlyNoteCommand","noteContext","tabManager","getActiveContext","viewScope","readOnlyTemporarilyDisabled","triggerEvent","showSQLConsoleCommand","sqlConsoleNote","createSqlConsole","openTabWithNoteWithHoisting","noteId","activate","ntxId","searchNotesCommand","searchString","ancestorNoteId","searchNote","createSearchNote","froca","loadSearchNote","triggerCommand","searchInSubtreeCommand","notePath","tree","getNoteIdFromUrl","this","openNoteExternallyCommand","getActiveContextNoteId","mime","getActiveContextNoteMime","openNoteExternally","openNoteCustomCommand","openNoteCustom","enterProtectedSessionCommand","enterProtectedSession","leaveProtectedSessionCommand","leaveProtectedSession","hideLeftPaneCommand","options","save","showLeftPaneCommand","toggleLeftPaneCommand","toggle","showBackendLogCommand","showLaunchBarSubtreeCommand","showAndHoistSubtree","showShareSubtreeCommand","showHiddenSubtreeCommand","showOptionsCommand","section","openContextWithNote","hoistedNoteId","showSQLConsoleHistoryCommand","showSearchHistoryCommand","subtreeNoteId","showNoteSourceCommand","getActiveContextNotePath","viewMode","showAttachmentsCommand","showAttachmentDetailCommand","toggleTrayCommand","utils","isElectron","BrowserWindow","dynamicRequire","windows","getAllWindows","action","every","w","isVisible","window","firstTabCommand","secondTabCommand","thirdTabCommand","fourthTabCommand","fifthTabCommand","sixthTabCommand","seventhTabCommand","eigthTabCommand","ninthTabCommand","lastTabCommand","Number","POSITIVE_INFINITY","tabNumber","mainNoteContexts","getMainNoteContexts","tab","length","activateNoteContext","Entrypoints","constructor","super","jQuery","hotkeys","filterInputAcceptingElements","filterContentEditable","filterTextInputs","openDevToolsCommand","getCurrentWindow","toggleDevTools","createNoteIntoInboxCommand","inboxNote","getInboxNote","note","server","post","content","type","isProtected","isProtectedSessionAvailable","ws","waitForMaxKnownEntityChangeId","isNewNote","toggleNoteHoistingCommand","noteToHoist","getNote","activeNoteContext","unhoist","setHoistedNoteId","hoistNoteCommand","unhoistCommand","copyWithoutFormattingCommand","copySelectionToClipboard","toggleFullscreenCommand","win","isFullScreenable","setFullScreen","isFullScreen","reloadFrontendAppCommand","reloadFrontendApp","logoutCommand","$logoutForm","$","append","glob","csrfToken","trigger","backInNoteHistoryCommand","webContents","getCurrentWebContents","activeIndex","parseInt","getActiveIndex","goToIndex","history","back","forwardInNoteHistoryCommand","forward","switchToDesktopVersionCommand","setCookie","switchToMobileVersionCommand","openInWindowCommand","extraWindowHash","calculateHash","ipcRenderer","send","url","location","protocol","host","pathname","open","openNewWindowCommand","runActiveNoteCommand","endsWith","bundle","getAndExecuteBundle","resp","success","toast","showError","error","results","showMessage","hideAllPopups","isDesktop","autocomplete","noteSwitchedEvent","activeContextChangedEvent","forceSaveRevisionCommand","NoteContext","mainNtxId","generateNtxId","resetViewScope","randomString","setEmpty","parentNoteId","isEmpty","setNote","inputNotePath","opts","triggerSwitchEvent","undefined","resolvedNotePath","getResolvedNotePath","areObjectsEqual","closeActiveDialog","getNoteIdAndParentIdFromUrl","saveToRecentNotes","touchProtectedSessionIfNecessary","setHoistedNoteIfNeeded","isMobile","screen","startsWith","isLabelTruthy","isLaunchBarConfig","isOptions","getSubContexts","noteContexts","filter","nc","isMainContext","getMainContext","getNoteContextById","e","setTimeout","async","resolveNotePath","checkNoteAccess","logError","notes","notePathArray","split","isActive","activeNtxId","getPojoState","active","noteIdToHoist","includes","isReadOnly","blob","getBlob","sizeLimit","getInt","contentLength","entitiesReloadedEvent","loadResults","isNoteReloaded","getEntityRow","isDeleted","hasNoteList","hasChildren","getTextEditor","callback","timeout","Promise","resolve","getCodeEditor","getContentElement","getTypeWidget","promise","race","res","getNavigationTitle","title","attachmentId","attachment","getAttachmentById","Mutex","current","lock","resolveFun","subPromise","newPromise","then","runExclusively","cb","unlock","TabManager","children","mutex","recentlyClosedTabs","tabsUpdate","isMainWindow","openNoteContexts","map","t","put","JSON","stringify","addBeforeUnloadListener","loadTabs","noteContextsToOpen","getJson","getNotes","flatMap","filteredNoteContexts","openTab","parsedFromUrl","parseNavigationStateFromUrl","href","push","find","allowUpdateWithoutChange","switchToNoteContext","get","message","stack","openEmptyTab","setCurrentNavigationStateToHash","scheduleUpdate","calculatedHash","hash","pushState","updateDocumentTitle","getNoteContexts","Error","getActiveMainContext","activeContext","getActiveContextNote","activeNote","getActiveContextNoteType","openAndActivateEmptyTab","existingNoteContext","child","openInNewTab","targetNoteId","openInSameTab","activateOrOpenNote","removeNoteContext","noteContextToRemove","noteContextsToRemove","ntxIdsToRemove","ntxIds","findIndex","activatePreviousTabCommand","activateNextTabCommand","siblings","idx","contextToActivate","removeNoteContexts","position","addToRecentlyClosedTabs","contexts","tabReorderEvent","ntxIdsInOrder","order","i","sort","a","b","noteContextReorderEvent","oldMainNtxId","newMainNtxId","Object","fromEntries","v","forEach","c","activeMainNtxId","oldIdx","newActiveNtxId","closeActiveTabCommand","beforeUnloadEvent","updateNowIfNecessary","openNewTabCommand","closeAllTabsCommand","ntxIdToRemove","closeOtherTabsCommand","closeTabCommand","moveTabToNewWindowCommand","reopenLastTabCommand","closeLastEmptyTab","lastClosedTab","pop","ntxsInOrder","slice","mainNtx","tabPosition","afterNtxId","noteContextToActivate","hoistedNoteChangedEvent","titleFragments","Boolean","document","join","frocaReloadedEvent","MobileScreenSwitcherExecutor","setActiveScreenCommand","activeScreen","MainTreeExecutors","noteTreeWidget","cloneNotesToCommand","selectedOrActiveNoteIds","getSelectedOrActiveNodes","node","data","noteIds","moveNotesToCommand","selectedOrActiveBranchIds","branchId","branchIds","createNoteIntoCommand","createNote","saveSelection","createNoteAfterCommand","getActiveNode","parentNotePath","getNotePath","getParent","getParentProtectedStatus","getHoistedNoteId","target","targetBranchId","ShortcutComponent","shortcutAttributes","attr","bindNoteShortcutHandler","labelOrRow","namespace","attributeId","removeGlobalShortcut","bindGlobalShortcut","value","getAttributeRows","name","AppContext","components","beforeUnloadListeners","setLayout","layout","start","initComponents","initializedPromise","renderWidgets","executeStartupBundles","component","zoom","rootWidget","getRootWidget","$renderedWidget","render","updateDisplayedShortcuts","on","hasClass","commandName","closest","prop","$el","handleEvent","executor","fun","callMethod","console","debug","getComponentByEl","el","obj","WeakRef","appContext","allSaved","wr","deref","weakRef","log","componentId","Component","sanitizedClassName","initialized","replace","setParent","parent","callMethodPromise","childrenPromise","handleEventInChildren","all","promises","ret","startTime","Date","now","call","took","isDev","timeLimit","ZoomComponent","setZoomFactor","getFloat","addEventListener","event","ctrlKey","setZoomFactorAndSave","getCurrentZoom","deltaY","zoomFactor","parseFloat","webFrame","Math","round","getZoomFactor","zoomOutEvent","zoomInEvent","zoomResetEvent","setZoomFactorAndSaveEvent","row","update","ownerId","role","dateModified","utcDateModified","utcDateScheduledForErasureSince","attachments","isInheritable","getTargetNote","isAutoLink","toString","isDefinition","getDefinition","parse","isDefinitionFor","dto","assign","notePosition","prefix","isExpanded","fromSearchNote","getNoteFromCache","getParentNote","isTopLevel","pojo","registeredClasses","Set","color","trim","normalizedColorName","className","has","add","LABEL","RELATION","NOTE_TYPE_ICONS","attributes","targetRelations","parents","parentToBranch","childToBranch","blobId","addParent","sortParents","addChild","childNoteId","sortChildren","branchIdPos","values","getBranch","isJson","getContent","getJsonContent","getParentBranchIds","getBranchIds","getParentBranches","getBranches","getChildBranches","getParentNoteIds","getParentNotes","getNotesFromCache","aNoteId","bNoteId","aBranchId","aNote","isArchived","isHiddenCompletely","hasAttribute","getChildNoteIds","getChildNotes","getAttachments","getAttachmentsForNote","getAttachmentsByRole","att","isEligibleForConversionToAttachment","isContentAvailable","getTargetRelations","relation","parentNote","referencingNote","getOwnedAttributes","attrs","__filterAttrs","getAttributes","__getCachedAttributes","path","newPath","attrArrs","__getInheritableAttributes","templateAttr","flat","templateNote","addedAttributeIds","isRoot","getAllNotePaths","parentNotes","notePaths","getSortedNotePathRecords","isHoistedRoot","isInHoistedSubTree","some","isSearch","isHidden","getBestNotePath","getBestNotePathString","__validateTypeName","firstLetter","charAt","getOwnedLabels","getLabels","getIcon","iconClassLabels","workspaceIconClass","getWorkspaceIconClass","isFolder","getColorClass","getLabelValue","getFilteredChildBranches","childBranches","getOwnedRelations","getRelations","hasOwnedAttribute","getOwnedAttribute","getAttribute","getOwnedAttributeValue","getAttributeValue","hasOwnedLabel","hasLabel","label","getLabel","hasOwnedRelation","hasRelation","getOwnedLabel","getOwnedRelation","getRelation","getOwnedLabelValue","getOwnedRelationValue","getRelationValue","getRelationTarget","targets","getRelationTargets","relations","getNotesToInheritAttributesFrom","rel","getPromotedDefinitionAttributes","promotedAttrs","def","isPromoted","hasAncestor","followTemplates","visitedNoteIds","isInHiddenSubtree","invalidateAttributeCache","getTargetRelationSourceNotes","tr","getNoteComplement","getCssClass","l","labels","getWorkspaceTabBackgroundColor","isJavaScript","isHtml","getScriptEnv","executeScript","env","bundleService","default","isShared","getMetadata","$widget","dateContextMenuOpenedMs","hide","show","empty","addItems","items","positionMenu","clientHeight","documentElement","clientWidth","contextMenuHeight","outerHeight","contextMenuWidth","outerWidth","top","left","y","orientation","x","css","display","addClass","$parent","item","$icon","uiIcon","$link","$item","stopPropagation","which","handler","selectMenuItemHandler","enabled","$subMenu","PROP_NAME","setupContextMenu","$image","preventDefault","pageX","pageY","command","copyImageReferenceToClipboard","copyImageAt","openContextMenu","subContexts","renderAttribute","attribute","renderIsInheritable","$attr","createTextNode","val","test","class","text","createLink","renderAttributes","$container","html","HIDDEN_ATTRIBUTES","renderNormalAttributes","promotedDefinitionAttributes","promAttr","$renderedAttributes","count","originEntity","script","params","executeBundle","apiContext","allNoteIds","eval","showAndLogError","scriptBundles","WidgetsByParent","byParent","widget","parentWidget","parentName","prototype","getWidgetBundlesByParent","widgetsByParent","idCounter","getRenderedContent","entity","tooltip","touchProtectedSession","getRenderingType","$renderedContent","isHtmlEmpty","childNoteIds","childNotes","childNote","showTooltip","showNoteIcon","renderChildrenList","requireLibrary","KATEX","renderMathInElement","trust","getNoteIdFromLink","referenceLinks","noteIdsToPrefetch","loadReferenceLinkTitle","renderText","renderCode","encodedTitle","encodeURIComponent","random","$img","imageHasZoom","WHEEL_ZOOM","WZoom","create","maxScale","speed","zoomOnClick","renderImage","entityType","entityId","$content","$pdfPreview","getUrlForDownload","$audioPreview","$videoPreview","$downloadButton","$openButton","downloadFileNote","renderFile","MERMAID","mermaidTheme","getComputedStyle","getPropertyValue","mermaid","mermaidAPI","initialize","startOnLoad","theme","securityLevel","svg","$error","renderMermaid","ctx","$button","getDayNote","date","dayjs","format","getTodayNote","getWeekNote","getMonthNote","month","getYearNote","year","info","confirm","confirmed","confirmDeleteNoteBoxWithNote","prompt","props","FBlob","getJsonContentSafely","loadInitialTree","branches","blobPromises","addResp","loadSubTree","subTreeNoteId","noteRows","branchRows","attributeRows","noteIdsToSort","noteRow","p","branch","branchRow","attributeRow","targetNote","reloadNotes","Array","from","searchResultNoteIds","highlightedTokens","isArray","resultNoteId","index","searchResultsLoaded","silentNotFoundError","trace","missingNoteIds","noteExists","getBranchId","getAttachment","attachmentRows","getWithSilentNotFound","logInfo","processAttachmentRows","attachmentRow","key","catch","isHoistedNode","isTopLevelNode","requestedNote","hoistedNote","isHoistedInHiddenSubtree","$imageWrapper","element","selection","getSelection","range","createRange","selectNodeContents","removeAllRanges","addRange","selectImage","execCommand","removeAttr","keyboardActionRepo","keyboardActionsLoaded","actions","actionName","effectiveShortcuts","shortcut","getActionsForScope","scope","getAction","silent","each","keyboardActions","shortcuts","newTitle","setupActionsForElement","bindElShortcut","getActions","loadedScriptPromises","requireScript","assetPath","ajax","dataType","cache","requireCss","prependAssetPath","querySelectorAll","library","cssUrl","js","scriptUrl","CKEDITOR","CODE_MIRROR","ESLINT","RELATION_MAP","PRINT_THIS","CALENDAR_WIDGET","FORCE_GRAPH","EXCALIDRAW","MARKJS","getLinkIcon","icon","paramStr","pair","keys","hashIdx","indexOf","substr","paramString","match","decodeURIComponent","warn","goToLink","evt","goToLinkExt","hrefLink","isCtrlKey","isLeftClick","isMiddleClick","leftClick","middleClick","withinEditLink","outsideOfCKEditor","toLowerCase","shell","openPath","getReferenceLinkTitle","address","getNotePathFromUrl","notePathMatch","exec","showNotePath","referenceLink","autoConvertToImage","linkTitle","getNoteTitle","$noteLink","resolvedNotePathSegments","resolveNotePathToSegments","getNotePathTitle","tagName","outerHTML","prepend","getReferenceLinkTitleSync","invalidate","focus","selectedHtml","dom","parseHTML","parseSelectedHtml","textEditor","getSelectedHtml","templateNoteId","removeSelection","chooseNoteType","createNoteWithTypePrompt","noteType","duplicateSubtree","origNote","mouseEnterHandler","linkId","floor","is","renderTooltip","tooltipClass","container","placement","boundary","template","sanitize","customClass","checkTooltip","bestNotePath","getNoteTitleWithPathAsSuffix","setupGlobalTooltip","remove","setupElementTooltip","checkType","getFileUrl","download","downloadURL","openCustom","isMac","filePath","tmpFilePath","platform","process","terminals","openFileWithTerminal","terminal","stdout","stderr","searchTerminal","err","URL","hostname","port","getHost","openExternally","electron","canOpenInBrowser","getOpenFileUrl","downloadRevision","revisionId","downloadAttachment","openAttachmentExternally","openAttachmentCustom","load","arr","getNames","set","payload","tokens","defObj","token","labelType","multiplicity","chunks","numberPrecision","promotedAlias","inverseRelation","protectedSessionDeferred","dfd","Deferred","makeToast","protectingLabel","id","taskId","protect","subscribeToMessages","reloadData","taskType","closePersistent","showPersistent","progressCount","closeAfter","protectNote","includingSubtree","resetProtectedSession","setupProtectedSession","password","enableProtectedSession","renderNoteIds","renderNoteId","$scriptContainer","startNote","currentNote","prepareParams","RightPanelWidget","NoteContextAwareWidget","BasicWidget","activateNote","activateNewNote","openTabWithNote","openSplitWithNote","addButtonToToolbar","reqBody","__runOnBackendInner","func","transactional","startNoteId","currentNoteId","originEntityName","originEntityId","executionResult","runOnBackend","runAsyncOnBackendWithManualTransactionHandling","searchForNotes","search","searchForNote","getInstanceName","instanceName","formatDateISO","parseDate","showInfoDialog","dialog","showConfirmDialog","showPromptDialog","createNoteLink","addTextToActiveContextEditor","getActiveContextTextEditor","getActiveContextCodeEditor","getActiveNoteDetailWidget","protectSubTree","waitUntilSynced","refreshIncludedNote","includedNoteId","formatSize","formatNoteSize","logMessages","logSpacedUpdates","messages","modules","allNotes","toObject","apis","require","moduleNoteIds","moduleName","candidates","exports","searchForNoteIds","ValidationError","getHeaders","headers","allHeaders","localNowDateTime","headerName","cookie","idToRequestMap","maxKnownEntityChangeId","method","ipc","requestId","reject","silentNotFound","baseApiUrl","rej","body","textStatus","jqXhr","respHeaders","getAllResponseHeaders","line","parts","header","shift","status","reportError","responseText","contentType","maxEntityChangeIdStr","max","handleSuccessfulResponse","arg","statusCode","response","toastService","requestUrl","showErrorTitleAndMessage","throwError","patch","upload","fileToUpload","formData","FormData","processData","getMaxKnownEntityChangeId","SpacedUpdate","updater","updateInterval","lastUpdated","changed","changeForbidden","triggerUpdate","isAllSavedAndTriggerUpdate","$toast","delay","autohide","logErrors","assertArguments","reverse","effectivePathSegments","pathToRoot","urlOrNotePath","segments","getNotePathTitleComponents","titleComponents","runPath","getBranchIdFromUrl","$titleWithPath","isNotePathInHiddenSubtree","LoadResults","entityChanges","entities","entityName","noteIdToComponentId","componentIdToNoteIds","noteReorderings","revisionRows","contentNoteIdToComponentId","optionNames","addNote","addBranch","getBranchRows","addNoteReordering","getNoteReorderings","addAttribute","addRevision","hasRevisionForNote","getNoteIds","componentIds","sId","addNoteContent","isNoteContentReloaded","addOption","isOptionReloaded","getOptionNames","addAttachmentRow","getAttachmentRows","hasAttributeRelatedChanges","isEmptyForTree","processNoteChange","ec","isErased","processBranchChange","processNoteReordering","parentNoteIdsToSort","positions","processAttributeChange","sourceNote","processAttachment","processEntityChanges","messageHandlers","lastPingTs","lastAcceptedEntityChangeId","maxEntityChangeIdAtLoad","lastAcceptedEntityChangeSyncId","maxEntityChangeSyncIdAtLoad","lastProcessedEntityChangeId","frontendUpdateDataQueue","readyState","consumeQueuePromise","processedEntityChangeIds","handleMessage","messageHandler","filteredRows","logRows","entityChange","isSynced","sendPing","allEntityChanges","nonProcessedEntityChanges","entityChangeIdReachedListeners","desiredEntityChangeId","resolvePromise","consumeFrontendUpdateData","executeFrontendUpdate","connectWebSocket","loc","webSocketUri","WebSocket","onopen","onmessage","OPEN","lastEntityChangeId","CLOSED","CLOSING","setInterval","getMaxKnownEntityChangeSyncId","style","classes","childPositionCounter","contentSized","collapsible","filling","cssBlock","block","cssEl","doRender","isEnabled","toggleInt","toggleClass","isHiddenInt","toggleExt","isHiddenExt","canBeShown","getPosition","getClosestNtxId","cleanup","isNoteContext","isActiveNoteContext","isNote","refresh","refreshWithNote","noteSwitched","activeContextChanged","noteSwitchedAndActivatedEvent","setNoteContextEvent","noteTypeMimeChangedEvent","widgetTitle","widgetButtons","help","$bodyWrapper","$body","$title","$buttons","buttonWidget","doRenderBody"],"sourceRoot":""}